// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package openapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// ActivityObject defines model for activity_object.
type ActivityObject struct {
	// Sum of intense and moderate activity durations (in seconds). *(Use 'data_fields' to request this data.)*
	Active *int `json:"active,omitempty"`

	// Specifies if data comes from Withings (device or mobile application tracker) or an external way (Value is 1 for Withings and 18 for external)
	Brand *int `json:"brand,omitempty"`

	// Active calories burned (in Kcal). Calculated by mixing fine granularity calories estimation, workouts estimated calories and calories manually set by the user. *(Use 'data_fields' to request this data.)*
	Calories *float32 `json:"calories,omitempty"`

	// Date of the aggregated data.
	Date *string `json:"date,omitempty"`

	// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
	Deviceid *string `json:"deviceid,omitempty"`

	// Distance travelled (in meters). *(Use 'data_fields' to request this data.)*
	Distance *float32 `json:"distance,omitempty"`

	// Number of floors climbed. *(Use 'data_fields' to request this data.)*
	Elevation *float32 `json:"elevation,omitempty"`

	// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
	HashDeviceid *string `json:"hash_deviceid,omitempty"`

	// Average heart rate. *(Use 'data_fields' to request this data.)*
	HrAverage *int `json:"hr_average,omitempty"`

	// Maximal heart rate. *(Use 'data_fields' to request this data.)*
	HrMax *int `json:"hr_max,omitempty"`

	// Minimal heart rate. *(Use 'data_fields' to request this data.)*
	HrMin *int `json:"hr_min,omitempty"`

	// Duration in seconds when heart rate was in a light zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
	HrZone0 *int `json:"hr_zone_0,omitempty"`

	// Duration in seconds when heart rate was in a moderate zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
	HrZone1 *int `json:"hr_zone_1,omitempty"`

	// Duration in seconds when heart rate was in an intense zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
	HrZone2 *int `json:"hr_zone_2,omitempty"`

	// Duration in seconds when heart rate was in maximal zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
	HrZone3 *int `json:"hr_zone_3,omitempty"`

	// Duration of intense activities (in seconds). *(Use 'data_fields' to request this data.)*
	Intense *int `json:"intense,omitempty"`

	// Is true if data was tracked by a Withings tracker (such as Pulse, Go and Watches) otherwise data was tracked by a mobile application or an external way
	IsTracker *bool `json:"is_tracker,omitempty"`

	// Duration of moderate activities (in seconds). *(Use 'data_fields' to request this data.)*
	Moderate *int `json:"moderate,omitempty"`

	// Duration of soft activities (in seconds). *(Use 'data_fields' to request this data.)*
	Soft *int `json:"soft,omitempty"`

	// Number of steps. *(Use 'data_fields' to request this data.)*
	Steps *int `json:"steps,omitempty"`

	// Timezone for the date.
	Timezone *string `json:"timezone,omitempty"`

	// Total calories burned (in Kcal). Obtained by adding active calories (see ```calories```) and passive calories.
	Totalcalories *float32 `json:"totalcalories,omitempty"`
}

// DropshipmentCreateOrderObject defines model for dropshipment_create_order_object.
type DropshipmentCreateOrderObject struct {
	// Random identifier you must provide in input parameters. It is used to track your order and must be unique.
	CustomerRefId *string `json:"customer_ref_id,omitempty"`

	// Withings generated identifier used to track your order.
	OrderId  *string                                 `json:"order_id,omitempty"`
	Products *[]DropshipmentCreateOrderProductObject `json:"products,omitempty"`

	// Status of the order. Value can be:
	//
	//
	// | Value|
	// |---|
	// |CREATED|
	// |ADDRESS VERIFICATION|
	// |ADDRESS ERROR|
	// |VERIFIED|
	// |PROCESSING|
	// |FAILED|
	// |OPEN|
	// |SHIPPED|
	// |TRASHED|
	// |BACKHOLD|
	Status *string `json:"status,omitempty"`
}

// DropshipmentCreateOrderProductObject defines model for dropshipment_create_order_product_object.
type DropshipmentCreateOrderProductObject struct {
	// EAN of the product.
	Ean *string `json:"ean,omitempty"`

	// Quantity of products.
	Quantity *int `json:"quantity,omitempty"`
}

// DropshipmentGetOrderStatusObject defines model for dropshipment_get_order_status_object.
type DropshipmentGetOrderStatusObject struct {
	// Carrier. *(Only if order has been shipped)*
	Carrier *string `json:"carrier,omitempty"`

	// Carrier service. *(Only if order has been shipped)*
	CarrierService *string `json:"carrier_service,omitempty"`

	// Random identifier you must provide in input parameters. It is used to track your order and must be unique.
	CustomerRefId *string `json:"customer_ref_id,omitempty"`

	// Withings generated identifier used to track your order.
	OrderId *string `json:"order_id,omitempty"`

	// Status of the parcel. *(Only if order has been shipped)* Value can be:
	//
	//
	// | Value|
	// |---|
	// |pending|
	// |info_received|
	// |in_transit|
	// |failed_attempt|
	// |exception|
	// |delayed|
	// |pickup|
	// |delivered|
	// |return|
	// |expired|
	ParcelStatus *string                                    `json:"parcel_status,omitempty"`
	Products     *[]DropshipmentGetOrderStatusProductObject `json:"products,omitempty"`

	// Status of the order. Value can be:
	//
	//
	// | Value|
	// |---|
	// |CREATED|
	// |ADDRESS VERIFICATION|
	// |ADDRESS ERROR|
	// |VERIFIED|
	// |PROCESSING|
	// |FAILED|
	// |OPEN|
	// |SHIPPED|
	// |TRASHED|
	// |BACKHOLD|
	Status *string `json:"status,omitempty"`

	// Tracking number. *(Only if order has been shipped)*
	TrackingNumber *string `json:"tracking_number,omitempty"`
}

// DropshipmentGetOrderStatusProductObject defines model for dropshipment_get_order_status_product_object.
type DropshipmentGetOrderStatusProductObject struct {
	// EAN of the product.
	Ean *string `json:"ean,omitempty"`

	// List of device MAC addresses. *(Only if order has been shipped)*
	MacAddresses *[]string `json:"mac_addresses,omitempty"`

	// Quantity of products.
	Quantity *int `json:"quantity,omitempty"`
}

// HeartMeasurementObject defines model for heart_measurement_object.
type HeartMeasurementObject struct {
	Bloodpressure *struct {
		// Diastole value.
		Diastole *int `json:"diastole,omitempty"`

		// Systole value.
		Systole *int `json:"systole,omitempty"`
	} `json:"bloodpressure,omitempty"`

	// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
	Deviceid *string `json:"deviceid,omitempty"`
	Ecg      *struct {
		// Atrial fibrillation classification.
		//
		//
		// | Value | Description|
		// |---|---|
		// |0 | Negative|
		// |1 | Positive|
		// |2 | Inconclusive|
		Afib *int `json:"afib,omitempty"`

		// Id of the signal.
		Signalid *int `json:"signalid,omitempty"`
	} `json:"ecg,omitempty"`

	// Average recorded heart rate.
	HeartRate *int `json:"heart_rate,omitempty"`

	// The source of the recording.
	//
	//
	// | Value | Description|
	// |---|---|
	// |44 | BPM Core|
	// |91 | Move ECG|
	Model *int `json:"model,omitempty"`

	// Timestamp of the recording.
	Timestamp *int64 `json:"timestamp,omitempty"`

	// Timezone for the date.
	Timezone *string `json:"timezone,omitempty"`
}

// MeasureObject defines model for measure_object.
type MeasureObject struct {
	// Deprecated.
	Algo *int `json:"algo,omitempty"`

	// Deprecated.
	Fm *int `json:"fm,omitempty"`

	// Deprecated.
	Fw *int `json:"fw,omitempty"`

	// Type of the measure. See ```meastype``` input parameter.
	Type *int `json:"type,omitempty"`

	// Power of ten to multiply the ```value``` field to get the real value.<br>Formula: ```value * 10^unit = real value```.<br>Eg: ```value = 20 and unit = -1 => real value = 2```.
	Unit *int `json:"unit,omitempty"`

	// Value for the measure in S.I. units (kilograms, meters etc...). Value should be multiplied by 10 to the power of ```units``` to get the real value.
	Value *int `json:"value,omitempty"`
}

// MeasuregrpObject defines model for measuregrp_object.
type MeasuregrpObject struct {
	// The way the measure was attributed to the user:
	//
	//
	// | Value | Description|
	// |---|---|
	// |0 | The measuregroup has been captured by a device and is known to belong to this user (and is not ambiguous)|
	// |1 | The measuregroup has been captured by a device but may belong to other users as well as this one (it is ambiguous)|
	// |2 | The measuregroup has been entered manually for this particular user|
	// |4 | The measuregroup has been entered manually during user creation (and may not be accurate)|
	// |5 | Measure auto, it's only for the Blood Pressure Monitor. This device can make many measures and computed the best value|
	// |7 | Measure confirmed. You can get this value if the user confirmed a detected activity|
	// |8 | Same as attrib 0|
	Attrib *int `json:"attrib,omitempty"`

	// Category for the measures in the group (see category input parameter).
	Category *int `json:"category,omitempty"`

	// Deprecated. This property will always be empty.
	Comment *string `json:"comment,omitempty"`

	// UNIX timestamp when measures were stored.
	Created *int64 `json:"created,omitempty"`

	// UNIX timestamp when measures were taken.
	Date *int64 `json:"date,omitempty"`

	// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
	Deviceid *string `json:"deviceid,omitempty"`

	// Unique identifier of the measure group.
	Grpid *int64 `json:"grpid,omitempty"`

	// List of measures in the group.
	Measures *[]MeasureObject `json:"measures,omitempty"`

	// Timezone for the date.
	Timezone *string `json:"timezone,omitempty"`
}

// NotifyObject defines model for notify_object.
type NotifyObject struct {
	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know the meaning of each values.
	Appli *int `json:"appli,omitempty"`

	// Callback url of the notification.
	Callbackurl *string `json:"callbackurl,omitempty"`

	// Comment entered when creating the notification configuration.
	Comment *string `json:"comment,omitempty"`

	// Date at which the notification configuration will expire.
	Expires *int64 `json:"expires,omitempty"`
}

// UserDeviceMacObject defines model for user_device_mac_object.
type UserDeviceMacObject struct {
	// Battery level: high (> 75%), medium (> 30%) or low
	Battery *string `json:"battery,omitempty"`

	// ID of the device. This ID is returned in other services to know which device tracked a data. Then device's model or type can be known using this information.
	Deviceid *string `json:"deviceid,omitempty"`

	// The timestamp of the last server connection of the device
	LastSessionDate *int64 `json:"last_session_date,omitempty"`

	// Serial number of provided as input parameter.
	MacAddress *string `json:"mac_address,omitempty"`

	// Device model. Value can be:
	//
	//
	// | Value | Description|
	// |---|---|
	// |Withings WBS01 | Scale|
	// |WS30 | Scale|
	// |Kid Scale | Scale|
	// |Smart Body Analyzer | Scale|
	// |Body+ | Scale|
	// |Body Cardio | Scale|
	// |Body | Scale|
	// |WBS08 | Scale|
	// |Body Pro | Scale|
	// |WBS10 | Scale|
	// |WBS11 | Scale|
	// |Smart Baby Monitor | Babyphone|
	// |Withings Home | Babyphone|
	// |Withings Blood Pressure Monitor V1 | Blood Pressure Monitor|
	// |Withings Blood Pressure Monitor V2 | Blood Pressure Monitor|
	// |Withings Blood Pressure Monitor V3 | Blood Pressure Monitor|
	// |BPM Core | Blood Pressure Monitor|
	// |BPM Connect | Blood Pressure Monitor|
	// |BPM Connect Pro | Blood Pressure Monitor|
	// |Pulse | Activity Tracker|
	// |Activite | Activity Tracker|
	// |Activite (Pop, Steel) | Activity Tracker|
	// |Withings Go | Activity Tracker|
	// |Activite Steel HR | Activity Tracker|
	// |Activite Steel HR Sport Edition | Activity Tracker|
	// |Pulse HR | Activity Tracker|
	// |Move | Activity Tracker|
	// |Move ECG | Activity Tracker|
	// |ScanWatch | Activity Tracker|
	// |Aura Dock | Sleep Monitor|
	// |Aura Sensor | Sleep Monitor|
	// |Aura Sensor V2 | Sleep Monitor|
	// |Thermo | Smart Connected Thermometer|
	// |WUP01 | Gateway|
	Model *string `json:"model,omitempty"`

	//
	//
	// | Value | Description|
	// |---|---|
	// |1 | Withings WBS01|
	// |2 | WS30|
	// |3 | Kid Scale|
	// |4 | Smart Body Analyzer|
	// |5 | Body+|
	// |6 | Body Cardio|
	// |7 | Body|
	// |10 | WBS08|
	// |9 | Body Pro|
	// |11 | WBS10|
	// |12 | WBS11|
	// |21 | Smart Baby Monitor|
	// |22 | Withings Home|
	// |41 | Withings Blood Pressure Monitor V1|
	// |42 | Withings Blood Pressure Monitor V2|
	// |43 | Withings Blood Pressure Monitor V3|
	// |44 | BPM Core|
	// |45 | BPM Connect|
	// |46 | BPM Connect Pro|
	// |51 | Pulse|
	// |52 | Activite|
	// |53 | Activite (Pop, Steel)|
	// |54 | Withings Go|
	// |55 | Activite Steel HR|
	// |59 | Activite Steel HR Sport Edition|
	// |58 | Pulse HR|
	// |90 | Move|
	// |91 | Move ECG|
	// |92 | Move ECG|
	// |93 | ScanWatch|
	// |60 | Aura Dock|
	// |61 | Aura Sensor|
	// |63 | Aura Sensor V2|
	// |70 | Thermo|
	// |100 | WUP01|
	ModelId *int `json:"model_id,omitempty"`

	// Timezone of the device.
	Timezone *string `json:"timezone,omitempty"`

	// Type of the device. Value can be:
	//
	//
	// | Value|
	// |---|
	// |Scale|
	// |Babyphone|
	// |Blood Pressure Monitor|
	// |Activity Tracker|
	// |Sleep Monitor|
	// |Smart Connected Thermometer|
	// |Gateway|
	Type *string `json:"type,omitempty"`
}

// UserDeviceObject defines model for user_device_object.
type UserDeviceObject struct {
	// Battery level: high (> 75%), medium (> 30%) or low
	Battery *string `json:"battery,omitempty"`

	// ID of the device. This ID is returned in other services to know which device tracked a data. Then device's model or type can be known using this information.
	Deviceid *string `json:"deviceid,omitempty"`

	// ID of the device. This ID is returned in other services to know which device tracked a data. Then device's model or type can be known using this information.
	HashDeviceid *string `json:"hash_deviceid,omitempty"`

	// The timestamp of the last server connection of the device
	LastSessionDate *int64 `json:"last_session_date,omitempty"`

	// Device model. Value can be:
	//
	//
	// | Value | Description|
	// |---|---|
	// |Withings WBS01 | Scale|
	// |WS30 | Scale|
	// |Kid Scale | Scale|
	// |Smart Body Analyzer | Scale|
	// |Body+ | Scale|
	// |Body Cardio | Scale|
	// |Body | Scale|
	// |WBS08 | Scale|
	// |Body Pro | Scale|
	// |WBS10 | Scale|
	// |WBS11 | Scale|
	// |Smart Baby Monitor | Babyphone|
	// |Withings Home | Babyphone|
	// |Withings Blood Pressure Monitor V1 | Blood Pressure Monitor|
	// |Withings Blood Pressure Monitor V2 | Blood Pressure Monitor|
	// |Withings Blood Pressure Monitor V3 | Blood Pressure Monitor|
	// |BPM Core | Blood Pressure Monitor|
	// |BPM Connect | Blood Pressure Monitor|
	// |BPM Connect Pro | Blood Pressure Monitor|
	// |Pulse | Activity Tracker|
	// |Activite | Activity Tracker|
	// |Activite (Pop, Steel) | Activity Tracker|
	// |Withings Go | Activity Tracker|
	// |Activite Steel HR | Activity Tracker|
	// |Activite Steel HR Sport Edition | Activity Tracker|
	// |Pulse HR | Activity Tracker|
	// |Move | Activity Tracker|
	// |Move ECG | Activity Tracker|
	// |ScanWatch | Activity Tracker|
	// |Aura Dock | Sleep Monitor|
	// |Aura Sensor | Sleep Monitor|
	// |Aura Sensor V2 | Sleep Monitor|
	// |Thermo | Smart Connected Thermometer|
	// |WUP01 | Gateway|
	Model *string `json:"model,omitempty"`

	//
	//
	// | Value | Description|
	// |---|---|
	// |1 | Withings WBS01|
	// |2 | WS30|
	// |3 | Kid Scale|
	// |4 | Smart Body Analyzer|
	// |5 | Body+|
	// |6 | Body Cardio|
	// |7 | Body|
	// |10 | WBS08|
	// |9 | Body Pro|
	// |11 | WBS10|
	// |12 | WBS11|
	// |21 | Smart Baby Monitor|
	// |22 | Withings Home|
	// |41 | Withings Blood Pressure Monitor V1|
	// |42 | Withings Blood Pressure Monitor V2|
	// |43 | Withings Blood Pressure Monitor V3|
	// |44 | BPM Core|
	// |45 | BPM Connect|
	// |46 | BPM Connect Pro|
	// |51 | Pulse|
	// |52 | Activite|
	// |53 | Activite (Pop, Steel)|
	// |54 | Withings Go|
	// |55 | Activite Steel HR|
	// |59 | Activite Steel HR Sport Edition|
	// |58 | Pulse HR|
	// |90 | Move|
	// |91 | Move ECG|
	// |92 | Move ECG|
	// |93 | ScanWatch|
	// |60 | Aura Dock|
	// |61 | Aura Sensor|
	// |63 | Aura Sensor V2|
	// |70 | Thermo|
	// |100 | WUP01|
	ModelId *int `json:"model_id,omitempty"`

	// Timezone of the device.
	Timezone *string `json:"timezone,omitempty"`

	// Type of the device. Value can be:
	//
	//
	// | Value|
	// |---|
	// |Scale|
	// |Babyphone|
	// |Blood Pressure Monitor|
	// |Activity Tracker|
	// |Sleep Monitor|
	// |Smart Connected Thermometer|
	// |Gateway|
	Type *string `json:"type,omitempty"`
}

// WorkoutObject defines model for workout_object.
type WorkoutObject struct {
	// The way the measure was attributed to the user:
	//
	//
	// | Value | Description|
	// |---|---|
	// |0 | The measuregroup has been captured by a device and is known to belong to this user (and is not ambiguous)|
	// |1 | The measuregroup has been captured by a device but may belong to other users as well as this one (it is ambiguous)|
	// |2 | The measuregroup has been entered manually for this particular user|
	// |4 | The measuregroup has been entered manually during user creation (and may not be accurate)|
	// |5 | Measure auto, it's only for the Blood Pressure Monitor. This device can make many measures and computed the best value|
	// |7 | Measure confirmed. You can get this value if the user confirmed a detected activity|
	// |8 | Same as attrib 0|
	Attrib *int `json:"attrib,omitempty"`

	// Category of workout:
	//
	//
	// | Value | Description|
	// |---|---|
	// |1 | Walk|
	// |2 | Run|
	// |3 | Hiking|
	// |4 | Skating|
	// |5 | BMX|
	// |6 | Bicycling|
	// |7 | Swimming|
	// |8 | Surfing|
	// |9 | Kitesurfing|
	// |10 | Windsurfing|
	// |11 | Bodyboard|
	// |12 | Tennis|
	// |13 | Table tennis|
	// |14 | Squash|
	// |15 | Badminton|
	// |16 | Lift weights|
	// |17 | Calisthenics|
	// |18 | Elliptical|
	// |19 | Pilates|
	// |20 | Basket-ball|
	// |21 | Soccer|
	// |22 | Football|
	// |23 | Rugby|
	// |24 | Volley-ball|
	// |25 | Waterpolo|
	// |26 | Horse riding|
	// |27 | Golf|
	// |28 | Yoga|
	// |29 | Dancing|
	// |30 | Boxing|
	// |31 | Fencing|
	// |32 | Wrestling|
	// |33 | Martial arts|
	// |34 | Skiing|
	// |35 | Snowboarding|
	// |36 | Other|
	// |128 | No activity|
	// |187 | Rowing|
	// |188 | Zumba|
	// |191 | Baseball|
	// |192 | Handball|
	// |193 | Hockey|
	// |194 | Ice hockey|
	// |195 | Climbing|
	// |196 | Ice skating|
	// |272 | Multi-sport|
	// |306 | Indoor walk|
	// |307 | Indoor running|
	// |308 | Indoor cycling|
	Category *int `json:"category,omitempty"`

	// Details of workout.
	Data *struct {
		// *Available for all categories except Multi-sport*<br><br>Total pause time in seconds detected by Withings device (swim only)
		AlgoPauseDuration *int `json:"algo_pause_duration,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Active calories burned (in Kcal). *(Use 'data_fields' to request this data.)*
		Calories *int `json:"calories,omitempty"`

		// *Available for all categories except Swimming, Multi-sport*<br><br>Distance travelled (in meters). *(Use 'data_fields' to request this data.)*
		Distance *int `json:"distance,omitempty"`

		// *Available for all categories except Swimming, Multi-sport*<br><br>Number of floors climbed. *(Use 'data_fields' to request this data.)*
		Elevation *int `json:"elevation,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Average heart rate. *(Use 'data_fields' to request this data.)*
		HrAverage *int `json:"hr_average,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Maximal heart rate. *(Use 'data_fields' to request this data.)*
		HrMax *int `json:"hr_max,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Minimal heart rate. *(Use 'data_fields' to request this data.)*
		HrMin *int `json:"hr_min,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Duration in seconds when heart rate was in a light zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
		HrZone0 *int `json:"hr_zone_0,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Duration in seconds when heart rate was in a moderate zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
		HrZone1 *int `json:"hr_zone_1,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Duration in seconds when heart rate was in an intense zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
		HrZone2 *int `json:"hr_zone_2,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Duration in seconds when heart rate was in maximal zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). *(Use 'data_fields' to request this data.)*
		HrZone3 *int `json:"hr_zone_3,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Intensity.
		Intensity *int `json:"intensity,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Active calories burned manually entered by user (in Kcal). *(Use 'data_fields' to request this data.)*
		ManualCalories *int `json:"manual_calories,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Distance travelled manually entered by user (in meters). *(Use 'data_fields' to request this data.)*
		ManualDistance *int `json:"manual_distance,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Total pause time in second filled by user
		PauseDuration *int `json:"pause_duration,omitempty"`

		// *Available only for Swimming*<br><br>Number of pool laps. *(Use 'data_fields' to request this data.)*
		PoolLaps *int `json:"pool_laps,omitempty"`

		// *Available only for Swimming*<br><br>Length of the pool. *(Use 'data_fields' to request this data.)*
		PoolLength *int `json:"pool_length,omitempty"`

		// *Available for all categories except Multi-sport*<br><br>Average percent of SpO2 percent value during a workout
		Spo2Average *int `json:"spo2_average,omitempty"`

		// *Available for all categories except Swimming, Multi-sport*<br><br>Number of steps. *(Use 'data_fields' to request this data.)*
		Steps *int `json:"steps,omitempty"`

		// *Available only for Swimming*<br><br>Number of strokes. *(Use 'data_fields' to request this data.)*
		Strokes *int `json:"strokes,omitempty"`
	} `json:"data,omitempty"`

	// Date at which the measure was taken or entered.
	Date *string `json:"date,omitempty"`

	// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
	Deviceid *string `json:"deviceid,omitempty"`

	// The ending datetime for workouts data.
	Enddate *int64 `json:"enddate,omitempty"`

	// Source for the workout. Value can be:
	//
	//
	// | Value | Description|
	// |---|---|
	// |1 | Withings WBS01, type: 1|
	// |2 | Withings WBS03, type: 1|
	// |3 | Kid Scale, type: 1|
	// |4 | Withings WBS02, type: 1|
	// |5 | Body+, type: 1|
	// |6 | Body Cardio, type: 1|
	// |7 | Body, type: 1|
	// |13 | Body+, type: 1|
	// |21 | Smart Baby Monitor, type: 2|
	// |22 | Withings Home, type: 2|
	// |41 | Withings Blood Pressure V1, type: 4|
	// |42 | Withings Blood Pressure V2, type: 4|
	// |43 | Withings Blood Pressure V3, type: 4|
	// |44 | BPM Core, type: 4|
	// |45 | BPM Connect, type: 4|
	// |51 | Pulse, type: 16|
	// |52 | Activite, type: 16|
	// |53 | Activite (Pop, Steel), type: 16|
	// |54 | Withings Go, type: 16|
	// |55 | Activite Steel HR, type: 16|
	// |58 | Pulse HR, type: 16|
	// |59 | Activite Steel HR Sport Edition, type: 16|
	// |60 | Aura dock, type: 32|
	// |61 | Aura sensor, type: 32|
	// |62 | Aura dock, type: 32|
	// |63 | Sleep sensor, type: 32|
	// |70 | Thermo, type: 64|
	// |91 | Move ECG|
	// |92 | Move ECG|
	// |1051 | iOS step tracker, type 16|
	// |1052 | iOS step tracker, type 16|
	// |1053 | Android step tracker, type 16|
	// |1054 | Android step tracker, type 16|
	// |1055 | GoogleFit tracker, type 16|
	// |1056 | Samsung Health tracker, type 16|
	// |1057 | HealthKit step iPhone tracker, type 16|
	// |1058 | HealthKit step Apple Watch tracker, type 16|
	// |1059 | HealthKit other step tracker, type 16|
	Model *int `json:"model,omitempty"`

	// The timestamp of the last modification.
	Modified *int64 `json:"modified,omitempty"`

	// The starting datetime for workouts data.
	Startdate *int64 `json:"startdate,omitempty"`

	// Timezone for the date.
	Timezone *string `json:"timezone,omitempty"`
}

// MeasureGetmeasParams defines parameters for MeasureGetmeas.
type MeasureGetmeasParams struct {
	// Requested measure type :
	//
	//
	// |Value | Description|
	// |---|---|
	// |1 | Weight (kg)|
	// |4 | Height (meter)|
	// |5 | Fat Free Mass (kg)|
	// |6 | Fat Ratio (%)|
	// |8 | Fat Mass Weight (kg)|
	// |9 | Diastolic Blood Pressure (mmHg)|
	// |10 | Systolic Blood Pressure (mmHg)|
	// |11 | Heart Pulse (bpm) - only for BPM and scale devices|
	// |12 | Temperature (celsius)|
	// |54 | SP02 (%)|
	// |71 | Body Temperature (celsius)|
	// |73 | Skin Temperature (celsius)|
	// |76 | Muscle Mass (kg)|
	// |77 | Hydration (kg)|
	// |88 | Bone Mass (kg)|
	// |91 | Pulse Wave Velocity (m/s)|
	// |123 | VO2 max is a numerical measurement of your body’s ability to consume oxygen (ml/min/kg).|
	// |135 | QRS interval duration based on ECG signal|
	// |136 | PR interval duration based on ECG signal|
	// |137 | QT interval duration based on ECG signal|
	// |138 | Corrected QT interval duration based on ECG signal|
	// |139 | Atrial fibrillation result from PPG|
	Meastype *int `json:"meastype,omitempty"`

	// List of requested measure types (separated by a comma).<br>Ex: meastypes=1,4,12
	Meastypes *[]int `json:"meastypes,omitempty"`

	// ```1``` for real measures, ```2``` for user objectives.
	Category *int `json:"category,omitempty"`

	// Measures' start date.
	Startdate *int `json:"startdate,omitempty"`

	// Measures' end date.
	Enddate *int `json:"enddate,omitempty"`

	// When a first call returns ```more:1``` and ```offset:XX```, set value ```XX``` in this parameter to retrieve next available rows.
	Offset *int `json:"offset,omitempty"`

	// Timestamp for requesting data that were updated or created after this date.<br>Useful for data synchronization between systems.<br>Use this instead of startdate + enddate.
	Lastupdate *int `json:"lastupdate,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// NotifyGetParams defines parameters for NotifyGet.
type NotifyGetParams struct {
	// Your ```Callback URL```.
	Callbackurl string `json:"callbackurl"`

	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know which value you should use.
	Appli *int `json:"appli,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// NotifyListParams defines parameters for NotifyList.
type NotifyListParams struct {
	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know which value you should use.
	Appli *int `json:"appli,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// NotifyRevokeParams defines parameters for NotifyRevoke.
type NotifyRevokeParams struct {
	// Your ```Callback URL```.
	Callbackurl *string `json:"callbackurl,omitempty"`

	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know which value you should use.
	Appli *int `json:"appli,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// NotifySubscribeParams defines parameters for NotifySubscribe.
type NotifySubscribeParams struct {
	// Your ```Callback URL```.
	Callbackurl string `json:"callbackurl"`

	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know which value you should use.
	Appli int `json:"appli"`

	// DO NOT USE WITH FOLLOWING PARAMS: [access_token]<br>Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// DO NOT USE WITH FOLLOWING PARAMS: [access_token]<br>A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// DO NOT USE WITH FOLLOWING PARAMS: [access_token]<br>Id of the client
	ClientId string `json:"client_id"`

	// Comment.
	Comment *string `json:"comment,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// NotifyUpdateParams defines parameters for NotifyUpdate.
type NotifyUpdateParams struct {
	// Your ```Callback URL```.
	Callbackurl string `json:"callbackurl"`

	// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know which value you should use.
	Appli int `json:"appli"`

	// DO NOT USE WITH FOLLOWING PARAMS: [new_appli, comment]<br>The new callback url.
	NewCallbackurl string `json:"new_callbackurl"`

	// DO NOT USE WITH FOLLOWING PARAMS: [new_callbackurl, comment]<br>The new application type.
	NewAppli int `json:"new_appli"`

	// DO NOT USE WITH FOLLOWING PARAMS: [new_callbackurl, new_appli]<br>Comment.
	Comment string `json:"comment"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Oauth2AuthorizeParams defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParams struct {
	// Must take the constant string value ```code```.
	ResponseType string `json:"response_type"`

	// Your ```Client ID```.
	ClientId string `json:"client_id"`

	// A value you define. This can be used to make sure that the redirect back to your site or app wasn’t spoofed.
	State string `json:"state"`

	// A comma-separated list of permission scopes you want to ask your user for (see the [Index Data API](/developer-guide/v3/data-api/all-available-health-data) section to know which scope you should use).
	Scope string `json:"scope"`

	// The URI we should redirect the user to after choosing to authorize or not your app. This URI must be set as ```Callback Url``` in your partner application. It is possible to use multiple URLs by separating them with a comma.<br />Examples:<br />
	// 									  <ul>
	// 										  <li>Callbacks: https://mydomain.com/</li>
	// 										  <li>Callback: https://mydomain.com/,https://mydomain2.com/</li>
	// 										  <li>Valid URL: https://mydomain.com/relative_path?args=value</li>
	// 									  </ul>
	RedirectUri string `json:"redirect_uri"`

	// Only set to use the demo user. For demo user must take the constant string value ```demo```.
	Mode *string `json:"mode,omitempty"`
}

// Dropshipmentv2CreateorderParams defines parameters for Dropshipmentv2Createorder.
type Dropshipmentv2CreateorderParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// Refer to [Order model](#section/Models/Order). The maximum number of orders is 10 per API request.
	Order map[string]interface{} `json:"order"`

	// Your dropshipment billing ID. If you don't know it, ignore this parameter.
	Customerid *string `json:"customerid,omitempty"`

	// If is set, it will create fake orders, and simulate the evolution of the orders status and sending of notifications.<br>```1```: ```SHIPPED``` sequence<br>```2```: ```TRASHED``` sequence<br>```3```: ```FAILED``` sequence<br>```4```: ```BACKHOLD``` sequence
	Testmode *int `json:"testmode,omitempty"`
}

// Dropshipmentv2CreateuserorderParams defines parameters for Dropshipmentv2Createuserorder.
type Dropshipmentv2CreateuserorderParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// Specifies if customer accepted Withings commercial contacts.
	Mailingpref bool `json:"mailingpref"`

	// Unix timestamp of user's birthdate
	Birthdate int `json:"birthdate"`

	// User measures (Cf. [Measures](#section/Models/Measures) model).
	Measures string `json:"measures"`

	// 0: man, 1: woman
	Gender int `json:"gender"`

	// User language preference. Examples: en_EN / en_US / de_DE / es_ES / fr_FR / it_IT / ja_JA / ko_KR / nl_NL / pt_PT / ru_RU / zh_CN
	Preflang string `json:"preflang"`

	// Unit pref (cf. [Unit preferences](#section/Models/Unit-preferences) model).
	UnitPref map[string]interface{} `json:"unit_pref"`

	// User's email address
	Email string `json:"email"`

	// User's timezone. Examples: "Europe/Paris" / "America/New_York". A complete list of all possible timezones can be found on the "TZ database name" column of this page : https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
	Timezone string `json:"timezone"`

	// 3 characters representing the end user (ex: for a user named Robert, you could set the shortname param to ROB). These characters will be displayed on device screens when used.<br>Shortname must respect the following regex: /^[a-zA-Z0-9]{3}$/ (either letters or numbers, special characters and spaces are not allowed).
	Shortname string `json:"shortname"`

	// Unique identifier used by the partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/)
	ExternalId string `json:"external_id"`

	// Refer to [Order model](#section/Models/Order). The maximum number of orders is 10 per API request.
	Order map[string]interface{} `json:"order"`

	// User's firstname (if not set, will take the same value as shortname)
	Firstname *string `json:"firstname,omitempty"`

	// User's lastname (if not set, will take the same value as shortname)
	Lastname *string `json:"lastname,omitempty"`

	// Phone number in E.164 format. End user will receive a verification code on this phone number for 2 factor authentication if they wish to securely access the data of their program in the withings app in the future (recommended)
	Phonenumber *string `json:"phonenumber,omitempty"`

	// Recovery code can be used by end user as a 2nd authentication factor in the withings app if they wish to securely access the data of their program in the future.  You will be responsible of securely providing this recovery code to your user if he asks for it.
	RecoveryCode *string `json:"recovery_code,omitempty"`

	// Goals (cf. [Goals](#section/Models/Goals) model).
	Goals *map[string]interface{} `json:"goals,omitempty"`

	// If is set, it will create fake orders, and simulate the evolution of the orders status and sending of notifications.<br>```1```: ```SHIPPED``` sequence<br>```2```: ```TRASHED``` sequence<br>```3```: ```FAILED``` sequence<br>```4```: ```BACKHOLD``` sequence
	Testmode *int `json:"testmode,omitempty"`
}

// Dropshipmentv2DeleteParams defines parameters for Dropshipmentv2Delete.
type Dropshipmentv2DeleteParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Withings generated identifier used to track your order.
	OrderId string `json:"order_id"`
}

// Dropshipmentv2GetorderstatusParams defines parameters for Dropshipmentv2Getorderstatus.
type Dropshipmentv2GetorderstatusParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// DO NOT USE WITH FOLLOWING PARAMS: [customer_ref_ids]<br>List of order_id
	OrderIds map[string]interface{} `json:"order_ids"`

	// DO NOT USE WITH FOLLOWING PARAMS: [order_ids]<br>Movement reference number of dropshipment orderlines
	CustomerRefIds map[string]interface{} `json:"customer_ref_ids"`

	// Your dropshipment billing ID. If you don't know it, ignore this parameter.
	Customerid *string `json:"customerid,omitempty"`
}

// Dropshipmentv2UpdateParams defines parameters for Dropshipmentv2Update.
type Dropshipmentv2UpdateParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Withings generated identifier used to track your order.
	OrderId string `json:"order_id"`

	// Refer to [Order model](#section/Models/Order). Restricted to one order only.
	Order map[string]interface{} `json:"order"`
}

// Heartv2GetParams defines parameters for Heartv2Get.
type Heartv2GetParams struct {
	// ID of a signal
	Signalid int `json:"signalid"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Heartv2ListParams defines parameters for Heartv2List.
type Heartv2ListParams struct {
	// Measures' start date.
	Startdate *int `json:"startdate,omitempty"`

	// Measures' end date.
	Enddate *int `json:"enddate,omitempty"`

	// When a first call returns ```more:true``` and ```offset:XX```, set value ```XX``` in this parameter to retrieve next available rows.
	Offset *int `json:"offset,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Measurev2GetintradayactivityParams defines parameters for Measurev2Getintradayactivity.
type Measurev2GetintradayactivityParams struct {
	// Measures' start date.
	Startdate *int `json:"startdate,omitempty"`

	// Measures' end date.
	Enddate *int `json:"enddate,omitempty"`

	// List of requested data fields, separated by a comma.<br>Available data fields are listed above.<br><u>Ex</u>: data_fields=steps,elevation,calories<br><br>steps<br>> Number of steps. <br><br>elevation<br>> Number of floors climbed. <br><br>calories<br>> Estimation of active calories burned (in Kcal). <br><br>distance<br>> Distance travelled (in meters). <br><br>stroke<br>> Number of strokes performed. <br><br>pool_lap<br>> Number of pool_lap performed. <br><br>duration<br>> Duration of the activity (in seconds). <br><br>heart_rate<br>> Measured heart rate. <br><br>spo2_auto<br>> SpO2 measurement automatically tracked by a device tracker<br><br>
	DataFields *string `json:"data_fields,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Measurev2GetactivityParams defines parameters for Measurev2Getactivity.
type Measurev2GetactivityParams struct {
	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>Start date.
	Startdateymd string `json:"startdateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>End date.
	Enddateymd string `json:"enddateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [startdateymd, enddateymd]<br>Timestamp for requesting data that were updated or created after this date.<br>Useful for data synchronization between systems.<br>Use this instead of startdateymd + enddateymd.
	Lastupdate int `json:"lastupdate"`

	// When a first call returns ```more:true``` and ```offset:XX```, set value ```XX``` in this parameter to retrieve next available rows.
	Offset *int `json:"offset,omitempty"`

	// List of requested data fields, separated by a comma.<br>Available data fields are listed above.<br><u>Ex</u>: data_fields=steps,distance,elevation<br><br>steps<br>> Number of steps. <br><br>distance<br>> Distance travelled (in meters). <br><br>elevation<br>> Number of floors climbed. <br><br>soft<br>> Duration of soft activities (in seconds). <br><br>moderate<br>> Duration of moderate activities (in seconds). <br><br>intense<br>> Duration of intense activities (in seconds). <br><br>active<br>> Sum of intense and moderate activity durations (in seconds). <br><br>calories<br>> Active calories burned (in Kcal). Calculated by mixing fine granularity calories estimation, workouts estimated calories and calories manually set by the user. <br><br>totalcalories<br>> Total calories burned (in Kcal). Obtained by adding active calories (see ```calories```) and passive calories.<br><br>hr_average<br>> Average heart rate. <br><br>hr_min<br>> Minimal heart rate. <br><br>hr_max<br>> Maximal heart rate. <br><br>hr_zone_0<br>> Duration in seconds when heart rate was in a light zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_1<br>> Duration in seconds when heart rate was in a moderate zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_2<br>> Duration in seconds when heart rate was in an intense zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_3<br>> Duration in seconds when heart rate was in maximal zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>
	DataFields *string `json:"data_fields,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Measurev2GetworkoutsParams defines parameters for Measurev2Getworkouts.
type Measurev2GetworkoutsParams struct {
	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>Start date.
	Startdateymd string `json:"startdateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>End date. Required if startdateymd is provided.
	Enddateymd string `json:"enddateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [startdateymd, enddateymd]<br>Timestamp for requesting data that were updated or created after this date.<br>Useful for data synchronization between systems.<br>Use this instead of startdateymd + enddateymd.
	Lastupdate int `json:"lastupdate"`

	// When a first call returns ```more:true``` and ```offset:XX```, set value ```XX``` in this parameter to retrieve next available rows.
	Offset *int `json:"offset,omitempty"`

	// List of requested data fields, separated by a comma.<br>Available data fields are listed above.<br><u>Ex</u>: data_fields=calories,intensity,manual_distance<br><br>calories<br>> Active calories burned (in Kcal). <br><br>intensity<br>> Intensity.<br><br>manual_distance<br>> Distance travelled manually entered by user (in meters). <br><br>manual_calories<br>> Active calories burned manually entered by user (in Kcal). <br><br>hr_average<br>> Average heart rate. <br><br>hr_min<br>> Minimal heart rate. <br><br>hr_max<br>> Maximal heart rate. <br><br>hr_zone_0<br>> Duration in seconds when heart rate was in a light zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_1<br>> Duration in seconds when heart rate was in a moderate zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_2<br>> Duration in seconds when heart rate was in an intense zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>hr_zone_3<br>> Duration in seconds when heart rate was in maximal zone (cf. <a href='/api-reference/#section/Glossary'>Glossary</a>). <br><br>pause_duration<br>> Total pause time in second filled by user<br><br>algo_pause_duration<br>> Total pause time in seconds detected by Withings device (swim only)<br><br>spo2_average<br>> Average percent of SpO2 percent value during a workout<br><br>steps<br>> Number of steps. <br><br>distance<br>> Distance travelled (in meters). <br><br>elevation<br>> Number of floors climbed. <br><br>pool_laps<br>> Number of pool laps. <br><br>strokes<br>> Number of strokes. <br><br>pool_length<br>> Length of the pool. <br><br>
	DataFields *string `json:"data_fields,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Oauth2GetdemoaccessParams defines parameters for Oauth2Getdemoaccess.
type Oauth2GetdemoaccessParams struct {
	// Your ```Client ID```.
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce)).
	Nonce string `json:"nonce"`

	// A comma-separated list of permission scopes you want to ask your user for (see the [Index Data API](/developer-guide/v3/data-api/all-available-health-data) section to know which scope you should use).
	ScopeOauth2 string `json:"scope_oauth2"`
}

// Oauth2RecoverauthorizationcodeParams defines parameters for Oauth2Recoverauthorizationcode.
type Oauth2RecoverauthorizationcodeParams struct {
	// Your ```Client ID```.
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce)).
	Nonce string `json:"nonce"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// User's email address
	Email string `json:"email"`
}

// Oauth2RefreshaccesstokenParams defines parameters for Oauth2Refreshaccesstoken.
type Oauth2RefreshaccesstokenParams struct {
	// Your ```Client ID```.
	ClientId string `json:"client_id"`

	// DO NOT USE WITH FOLLOWING PARAMS: [client_secret]. A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce)).
	Nonce string `json:"nonce"`

	// DO NOT USE WITH FOLLOWING PARAMS: [client_secret]. Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// DO NOT USE WITH FOLLOWING PARAMS: [signature,nonce]. Your ```Client Secret```.
	ClientSecret string `json:"client_secret"`

	// Must take the constant string value ```refresh_token```.
	GrantType string `json:"grant_type"`

	// The current valid ```refresh_token```.
	RefreshToken string `json:"refresh_token"`
}

// Oauth2GetaccesstokenParams defines parameters for Oauth2Getaccesstoken.
type Oauth2GetaccesstokenParams struct {
	// Your ```Client ID```.
	ClientId string `json:"client_id"`

	// DO NOT USE WITH FOLLOWING PARAMS: [client_secret]. A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce)).
	Nonce string `json:"nonce"`

	// DO NOT USE WITH FOLLOWING PARAMS: [client_secret]. Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// DO NOT USE WITH FOLLOWING PARAMS: [signature,nonce]. Your ```Client Secret```.
	ClientSecret string `json:"client_secret"`

	// Must take the constant string value ```authorization_code```.
	GrantType string `json:"grant_type"`

	// The Authorization Code you got from previous step.
	Code string `json:"code"`

	// The URI you use in the first call.
	RedirectUri string `json:"redirect_uri"`
}

// Orderv2GetdetailParams defines parameters for Orderv2Getdetail.
type Orderv2GetdetailParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// DO NOT USE WITH FOLLOWING PARAMS: [customer_ref_ids]<br>List of order_id
	OrderIds map[string]interface{} `json:"order_ids"`

	// DO NOT USE WITH FOLLOWING PARAMS: [order_ids]<br>Movement reference number of dropshipment orderlines
	CustomerRefIds map[string]interface{} `json:"customer_ref_ids"`

	// Your dropshipment billing ID. If you don't know it, ignore this parameter.
	Customerid *string `json:"customerid,omitempty"`
}

// Signaturev2GetnonceParams defines parameters for Signaturev2Getnonce.
type Signaturev2GetnonceParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// unix timestamp
	Timestamp int `json:"timestamp"`

	// Cf. description above.
	Signature string `json:"signature"`
}

// Sleepv2GetParams defines parameters for Sleepv2Get.
type Sleepv2GetParams struct {
	// Measures' start date.
	Startdate int `json:"startdate"`

	// Measures' end date.
	Enddate int `json:"enddate"`

	// List of requested data fields, separated by a comma.<br>Available data fields are listed above.<br><u>Ex</u>: data_fields=hr,rr,snoring<br><br>hr<br>> Heart Rate. <br><br>rr<br>> Respiration Rate. <br><br>snoring<br>> Total snoring time<br><br>sdnn_1<br>> Heart rate variability - Standard deviation of the NN over 1 minute<br><br>rmssd<br>> Heart rate variability - Root mean square of the successive differences over "a few seconds"<br><br>
	DataFields *string `json:"data_fields,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Sleepv2GetsummaryParams defines parameters for Sleepv2Getsummary.
type Sleepv2GetsummaryParams struct {
	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>Start date. Required if no lastupdate.
	Startdateymd string `json:"startdateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [lastupdate]<br>End date. Required if startdateymd is provided.
	Enddateymd string `json:"enddateymd"`

	// DO NOT USE WITH FOLLOWING PARAMS: [startdateymd, enddateymd]<br>Timestamp for requesting data that were updated or created after this date.<br>Useful for data synchronization between systems.<br>Use this instead of startdateymd + enddateymd.
	Lastupdate int `json:"lastupdate"`

	// List of requested data fields, separated by a comma.<br>Available data fields are listed above.<br><u>Ex</u>: data_fields=apnea_hypopnea_index,asleepduration,breathing_disturbances_intensity<br><br><b><i>Standard sleep medicine metrics</i></b><br><br>nb_rem_episodes<br>> Count of the REM sleep phases. <br><br>sleep_efficiency<br>> Ratio of the total sleep time over the time spent in bed. <br><br>sleep_latency<br>> Time spent in bed before falling asleep. <br><br>total_sleep_time<br>> Total time spent asleep. Sum of light, deep and rem durations. <br><br>total_timeinbed<br>> Total time spent in bed. <br><br>wakeup_latency<br>> Time spent in bed after waking up. <br><br>waso<br>> Time spent awake in bed after falling asleep for the 1st time during the night. <br><br><br><b><i>Sleep apnea and breathing disturbances</i></b><br><br>apnea_hypopnea_index<br>> Medical grade AHI. Only available for devices purchased in Europe and Australia, with the sleep apnea detection feature activated. Average number of hypopnea and apnea episodes per hour, that occured during sleep time.<br><br>breathing_disturbances_intensity<br>> Wellness metric, available for all Sleep and Sleep Analyzer devices. Intensity of <a href='/api-reference/#section/Glossary'>breathing disturbances</a><br><br><br><b><i>Other sleep datapoints and vitals</i></b><br><br>asleepduration<br>> Duration of sleep when night comes from external source (light, deep and rem sleep durations are null in this case). <br><br>deepsleepduration<br>> Duration in state deep sleep (in seconds). <br><br>durationtosleep<br>> Time to sleep (in seconds). (deprecated) <br><br>durationtowakeup<br>> Time to wake up (in seconds). (deprecated) <br><br>hr_average<br>> Average heart rate. <br><br>hr_max<br>> Maximal heart rate. <br><br>hr_min<br>> Minimal heart rate. <br><br>lightsleepduration<br>> Duration in state light sleep (in seconds). <br><br>night_events<br>> Events list happened during the night<br><br>out_of_bed_count<br>> Number of times the user got out of bed during the night. <br><br>remsleepduration<br>> Duration in state REM sleep (in seconds). <br><br>rr_average<br>> Average respiration rate. <br><br>rr_max<br>> Maximal respiration rate. <br><br>rr_min<br>> Minimal respiration rate. <br><br>sleep_score<br>> Sleep score<br><br>snoring<br>> Total snoring time<br><br>snoringepisodecount<br>> Numbers of snoring episodes of at least one minute<br><br>wakeupcount<br>> Number of times the user woke up while in bed. Does not include the number of times the user got out of bed. <br><br>wakeupduration<br>> Time spent awake (in seconds). <br><br>
	DataFields *string `json:"data_fields,omitempty"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Userv2ActivateParams defines parameters for Userv2Activate.
type Userv2ActivateParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// Specifies if customer accepted Withings commercial contacts.
	Mailingpref bool `json:"mailingpref"`

	// Unix timestamp of user's birthdate
	Birthdate int `json:"birthdate"`

	// User measures (Cf. [Measures](#section/Models/Measures) model).
	Measures string `json:"measures"`

	// 0: man, 1: woman
	Gender int `json:"gender"`

	// User language preference. Examples: en_EN / en_US / de_DE / es_ES / fr_FR / it_IT / ja_JA / ko_KR / nl_NL / pt_PT / ru_RU / zh_CN
	Preflang string `json:"preflang"`

	// Unit pref (cf. [Unit preferences](#section/Models/Unit-preferences) model).
	UnitPref map[string]interface{} `json:"unit_pref"`

	// User's email address
	Email string `json:"email"`

	// User's timezone. Examples: "Europe/Paris" / "America/New_York". A complete list of all possible timezones can be found on the "TZ database name" column of this page : https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
	Timezone string `json:"timezone"`

	// 3 characters representing the end user (ex: for a user named Robert, you could set the shortname param to ROB). These characters will be displayed on device screens when used.<br>Shortname must respect the following regex: /^[a-zA-Z0-9]{3}$/ (either letters or numbers, special characters and spaces are not allowed).
	Shortname string `json:"shortname"`

	// Unique identifier used by the partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/)
	ExternalId string `json:"external_id"`

	// List of Withings device MAC addresses that will be linked to the created user. Example: ["00:24:e4:xx:xx:xx","00:24:e4:xx:xx:xx"]
	MacAddresses string `json:"mac_addresses"`

	// User's firstname (if not set, will take the same value as shortname)
	Firstname *string `json:"firstname,omitempty"`

	// User's lastname (if not set, will take the same value as shortname)
	Lastname *string `json:"lastname,omitempty"`

	// Phone number in E.164 format. End user will receive a verification code on this phone number for 2 factor authentication if they wish to securely access the data of their program in the withings app in the future (recommended)
	Phonenumber *string `json:"phonenumber,omitempty"`

	// Recovery code can be used by end user as a 2nd authentication factor in the withings app if they wish to securely access the data of their program in the future.  You will be responsible of securely providing this recovery code to your user if he asks for it.
	RecoveryCode *string `json:"recovery_code,omitempty"`

	// Goals (cf. [Goals](#section/Models/Goals) model).
	Goals *map[string]interface{} `json:"goals,omitempty"`
}

// Userv2GetParams defines parameters for Userv2Get.
type Userv2GetParams struct {
	// Id of the client
	ClientId string `json:"client_id"`

	// A random token used to prevent replay attacks (Cf. [Signature v2 - Getnonce](#operation/signaturev2-getnonce))
	Nonce string `json:"nonce"`

	// Hash of params (Cf. [Signature hash protocol](/developer-guide/v3/get-access/sign-your-requests)).
	Signature string `json:"signature"`

	// User's email address
	Email string `json:"email"`
}

// Userv2GetdeviceParams defines parameters for Userv2Getdevice.
type Userv2GetdeviceParams struct {
	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Userv2GetgoalsParams defines parameters for Userv2Getgoals.
type Userv2GetgoalsParams struct {
	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Userv2LinkParams defines parameters for Userv2Link.
type Userv2LinkParams struct {
	// List of Withings device MAC addresses that will be linked to the created user. Example: ["00:24:e4:xx:xx:xx","00:24:e4:xx:xx:xx"]
	MacAddresses string `json:"mac_addresses"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// Userv2UnlinkParams defines parameters for Userv2Unlink.
type Userv2UnlinkParams struct {
	// The mac address of the target device.
	MacAddress string `json:"mac_address"`

	// Used to pass your access token. Must take value: ```Bearer {your access_token}``` Replace {your access_token} with the access_token
	Authorization string `json:"Authorization"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// MeasureGetmeas request
	MeasureGetmeas(ctx context.Context, params *MeasureGetmeasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyGet request
	NotifyGet(ctx context.Context, params *NotifyGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyList request
	NotifyList(ctx context.Context, params *NotifyListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyRevoke request
	NotifyRevoke(ctx context.Context, params *NotifyRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifySubscribe request
	NotifySubscribe(ctx context.Context, params *NotifySubscribeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotifyUpdate request
	NotifyUpdate(ctx context.Context, params *NotifyUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Authorize request
	Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dropshipmentv2Createorder request
	Dropshipmentv2Createorder(ctx context.Context, params *Dropshipmentv2CreateorderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dropshipmentv2Createuserorder request
	Dropshipmentv2Createuserorder(ctx context.Context, params *Dropshipmentv2CreateuserorderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dropshipmentv2Delete request
	Dropshipmentv2Delete(ctx context.Context, params *Dropshipmentv2DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dropshipmentv2Getorderstatus request
	Dropshipmentv2Getorderstatus(ctx context.Context, params *Dropshipmentv2GetorderstatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dropshipmentv2Update request
	Dropshipmentv2Update(ctx context.Context, params *Dropshipmentv2UpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Heartv2Get request
	Heartv2Get(ctx context.Context, params *Heartv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Heartv2List request
	Heartv2List(ctx context.Context, params *Heartv2ListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Measurev2Getintradayactivity request
	Measurev2Getintradayactivity(ctx context.Context, params *Measurev2GetintradayactivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Measurev2Getactivity request
	Measurev2Getactivity(ctx context.Context, params *Measurev2GetactivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Measurev2Getworkouts request
	Measurev2Getworkouts(ctx context.Context, params *Measurev2GetworkoutsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Getdemoaccess request
	Oauth2Getdemoaccess(ctx context.Context, params *Oauth2GetdemoaccessParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Recoverauthorizationcode request
	Oauth2Recoverauthorizationcode(ctx context.Context, params *Oauth2RecoverauthorizationcodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Refreshaccesstoken request
	Oauth2Refreshaccesstoken(ctx context.Context, params *Oauth2RefreshaccesstokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Getaccesstoken request
	Oauth2Getaccesstoken(ctx context.Context, params *Oauth2GetaccesstokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Orderv2Getdetail request
	Orderv2Getdetail(ctx context.Context, params *Orderv2GetdetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Signaturev2Getnonce request
	Signaturev2Getnonce(ctx context.Context, params *Signaturev2GetnonceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sleepv2Get request
	Sleepv2Get(ctx context.Context, params *Sleepv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sleepv2Getsummary request
	Sleepv2Getsummary(ctx context.Context, params *Sleepv2GetsummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Activate request
	Userv2Activate(ctx context.Context, params *Userv2ActivateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Get request
	Userv2Get(ctx context.Context, params *Userv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Getdevice request
	Userv2Getdevice(ctx context.Context, params *Userv2GetdeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Getgoals request
	Userv2Getgoals(ctx context.Context, params *Userv2GetgoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Link request
	Userv2Link(ctx context.Context, params *Userv2LinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userv2Unlink request
	Userv2Unlink(ctx context.Context, params *Userv2UnlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) MeasureGetmeas(ctx context.Context, params *MeasureGetmeasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeasureGetmeasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyGet(ctx context.Context, params *NotifyGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyList(ctx context.Context, params *NotifyListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyRevoke(ctx context.Context, params *NotifyRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyRevokeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifySubscribe(ctx context.Context, params *NotifySubscribeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifySubscribeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotifyUpdate(ctx context.Context, params *NotifyUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotifyUpdateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dropshipmentv2Createorder(ctx context.Context, params *Dropshipmentv2CreateorderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropshipmentv2CreateorderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dropshipmentv2Createuserorder(ctx context.Context, params *Dropshipmentv2CreateuserorderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropshipmentv2CreateuserorderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dropshipmentv2Delete(ctx context.Context, params *Dropshipmentv2DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropshipmentv2DeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dropshipmentv2Getorderstatus(ctx context.Context, params *Dropshipmentv2GetorderstatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropshipmentv2GetorderstatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dropshipmentv2Update(ctx context.Context, params *Dropshipmentv2UpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropshipmentv2UpdateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Heartv2Get(ctx context.Context, params *Heartv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartv2GetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Heartv2List(ctx context.Context, params *Heartv2ListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartv2ListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Measurev2Getintradayactivity(ctx context.Context, params *Measurev2GetintradayactivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeasurev2GetintradayactivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Measurev2Getactivity(ctx context.Context, params *Measurev2GetactivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeasurev2GetactivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Measurev2Getworkouts(ctx context.Context, params *Measurev2GetworkoutsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeasurev2GetworkoutsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Getdemoaccess(ctx context.Context, params *Oauth2GetdemoaccessParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2GetdemoaccessRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Recoverauthorizationcode(ctx context.Context, params *Oauth2RecoverauthorizationcodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2RecoverauthorizationcodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Refreshaccesstoken(ctx context.Context, params *Oauth2RefreshaccesstokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2RefreshaccesstokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Getaccesstoken(ctx context.Context, params *Oauth2GetaccesstokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2GetaccesstokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Orderv2Getdetail(ctx context.Context, params *Orderv2GetdetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderv2GetdetailRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Signaturev2Getnonce(ctx context.Context, params *Signaturev2GetnonceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignaturev2GetnonceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sleepv2Get(ctx context.Context, params *Sleepv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSleepv2GetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sleepv2Getsummary(ctx context.Context, params *Sleepv2GetsummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSleepv2GetsummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Activate(ctx context.Context, params *Userv2ActivateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2ActivateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Get(ctx context.Context, params *Userv2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2GetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Getdevice(ctx context.Context, params *Userv2GetdeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2GetdeviceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Getgoals(ctx context.Context, params *Userv2GetgoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2GetgoalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Link(ctx context.Context, params *Userv2LinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2LinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userv2Unlink(ctx context.Context, params *Userv2UnlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserv2UnlinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewMeasureGetmeasRequest generates requests for MeasureGetmeas
func NewMeasureGetmeasRequest(server string, params *MeasureGetmeasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/measure?action=getmeas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Meastype != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meastype", runtime.ParamLocationQuery, *params.Meastype); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Meastypes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meastypes", runtime.ParamLocationQuery, *params.Meastypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Category != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Startdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdate", runtime.ParamLocationQuery, *params.Startdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Enddate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddate", runtime.ParamLocationQuery, *params.Enddate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lastupdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastupdate", runtime.ParamLocationQuery, *params.Lastupdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewNotifyGetRequest generates requests for NotifyGet
func NewNotifyGetRequest(server string, params *NotifyGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notify?action=get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callbackurl", runtime.ParamLocationQuery, params.Callbackurl); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Appli != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appli", runtime.ParamLocationQuery, *params.Appli); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewNotifyListRequest generates requests for NotifyList
func NewNotifyListRequest(server string, params *NotifyListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notify?action=list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Appli != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appli", runtime.ParamLocationQuery, *params.Appli); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewNotifyRevokeRequest generates requests for NotifyRevoke
func NewNotifyRevokeRequest(server string, params *NotifyRevokeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notify?action=revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Callbackurl != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callbackurl", runtime.ParamLocationQuery, *params.Callbackurl); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Appli != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appli", runtime.ParamLocationQuery, *params.Appli); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewNotifySubscribeRequest generates requests for NotifySubscribe
func NewNotifySubscribeRequest(server string, params *NotifySubscribeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notify?action=subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callbackurl", runtime.ParamLocationQuery, params.Callbackurl); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appli", runtime.ParamLocationQuery, params.Appli); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Comment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment", runtime.ParamLocationQuery, *params.Comment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewNotifyUpdateRequest generates requests for NotifyUpdate
func NewNotifyUpdateRequest(server string, params *NotifyUpdateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notify?action=update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callbackurl", runtime.ParamLocationQuery, params.Callbackurl); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appli", runtime.ParamLocationQuery, params.Appli); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "new_callbackurl", runtime.ParamLocationQuery, params.NewCallbackurl); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "new_appli", runtime.ParamLocationQuery, params.NewAppli); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment", runtime.ParamLocationQuery, params.Comment); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewOauth2AuthorizeRequest generates requests for Oauth2Authorize
func NewOauth2AuthorizeRequest(server string, params *Oauth2AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2_user/authorize2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Mode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropshipmentv2CreateorderRequest generates requests for Dropshipmentv2Createorder
func NewDropshipmentv2CreateorderRequest(server string, params *Dropshipmentv2CreateorderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/dropshipment?action=createorder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, params.Order); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Customerid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customerid", runtime.ParamLocationQuery, *params.Customerid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Testmode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "testmode", runtime.ParamLocationQuery, *params.Testmode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropshipmentv2CreateuserorderRequest generates requests for Dropshipmentv2Createuserorder
func NewDropshipmentv2CreateuserorderRequest(server string, params *Dropshipmentv2CreateuserorderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/dropshipment?action=createuserorder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailingpref", runtime.ParamLocationQuery, params.Mailingpref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "birthdate", runtime.ParamLocationQuery, params.Birthdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "measures", runtime.ParamLocationQuery, params.Measures); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gender", runtime.ParamLocationQuery, params.Gender); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preflang", runtime.ParamLocationQuery, params.Preflang); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_pref", runtime.ParamLocationQuery, params.UnitPref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, params.Timezone); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shortname", runtime.ParamLocationQuery, params.Shortname); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_id", runtime.ParamLocationQuery, params.ExternalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, params.Order); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Firstname != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firstname", runtime.ParamLocationQuery, *params.Firstname); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lastname != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastname", runtime.ParamLocationQuery, *params.Lastname); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Phonenumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phonenumber", runtime.ParamLocationQuery, *params.Phonenumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RecoveryCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recovery_code", runtime.ParamLocationQuery, *params.RecoveryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Goals != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "goals", runtime.ParamLocationQuery, *params.Goals); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Testmode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "testmode", runtime.ParamLocationQuery, *params.Testmode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropshipmentv2DeleteRequest generates requests for Dropshipmentv2Delete
func NewDropshipmentv2DeleteRequest(server string, params *Dropshipmentv2DeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/dropshipment?action=delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropshipmentv2GetorderstatusRequest generates requests for Dropshipmentv2Getorderstatus
func NewDropshipmentv2GetorderstatusRequest(server string, params *Dropshipmentv2GetorderstatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/dropshipment?action=getorderstatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_ids", runtime.ParamLocationQuery, params.OrderIds); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_ref_ids", runtime.ParamLocationQuery, params.CustomerRefIds); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Customerid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customerid", runtime.ParamLocationQuery, *params.Customerid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDropshipmentv2UpdateRequest generates requests for Dropshipmentv2Update
func NewDropshipmentv2UpdateRequest(server string, params *Dropshipmentv2UpdateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/dropshipment?action=update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, params.Order); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeartv2GetRequest generates requests for Heartv2Get
func NewHeartv2GetRequest(server string, params *Heartv2GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/heart?action=get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signalid", runtime.ParamLocationQuery, params.Signalid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewHeartv2ListRequest generates requests for Heartv2List
func NewHeartv2ListRequest(server string, params *Heartv2ListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/heart?action=list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Startdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdate", runtime.ParamLocationQuery, *params.Startdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Enddate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddate", runtime.ParamLocationQuery, *params.Enddate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewMeasurev2GetintradayactivityRequest generates requests for Measurev2Getintradayactivity
func NewMeasurev2GetintradayactivityRequest(server string, params *Measurev2GetintradayactivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/measure$getintradayactivity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Startdate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdate", runtime.ParamLocationQuery, *params.Startdate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Enddate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddate", runtime.ParamLocationQuery, *params.Enddate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DataFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_fields", runtime.ParamLocationQuery, *params.DataFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewMeasurev2GetactivityRequest generates requests for Measurev2Getactivity
func NewMeasurev2GetactivityRequest(server string, params *Measurev2GetactivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/measure?action=getactivity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdateymd", runtime.ParamLocationQuery, params.Startdateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddateymd", runtime.ParamLocationQuery, params.Enddateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastupdate", runtime.ParamLocationQuery, params.Lastupdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DataFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_fields", runtime.ParamLocationQuery, *params.DataFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewMeasurev2GetworkoutsRequest generates requests for Measurev2Getworkouts
func NewMeasurev2GetworkoutsRequest(server string, params *Measurev2GetworkoutsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/measure?action=getworkouts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdateymd", runtime.ParamLocationQuery, params.Startdateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddateymd", runtime.ParamLocationQuery, params.Enddateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastupdate", runtime.ParamLocationQuery, params.Lastupdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DataFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_fields", runtime.ParamLocationQuery, *params.DataFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewOauth2GetdemoaccessRequest generates requests for Oauth2Getdemoaccess
func NewOauth2GetdemoaccessRequest(server string, params *Oauth2GetdemoaccessParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/oauth2?action=getdemoaccess")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope_oauth2", runtime.ParamLocationQuery, params.ScopeOauth2); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2RecoverauthorizationcodeRequest generates requests for Oauth2Recoverauthorizationcode
func NewOauth2RecoverauthorizationcodeRequest(server string, params *Oauth2RecoverauthorizationcodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/oauth2?action=recoverauthorizationcode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2RefreshaccesstokenRequest generates requests for Oauth2Refreshaccesstoken
func NewOauth2RefreshaccesstokenRequest(server string, params *Oauth2RefreshaccesstokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/oauth2?action=refreshaccesstoken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, params.ClientSecret); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grant_type", runtime.ParamLocationQuery, params.GrantType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh_token", runtime.ParamLocationQuery, params.RefreshToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2GetaccesstokenRequest generates requests for Oauth2Getaccesstoken
func NewOauth2GetaccesstokenRequest(server string, params *Oauth2GetaccesstokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/oauth2?action=requesttoken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, params.ClientSecret); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grant_type", runtime.ParamLocationQuery, params.GrantType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderv2GetdetailRequest generates requests for Orderv2Getdetail
func NewOrderv2GetdetailRequest(server string, params *Orderv2GetdetailParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/order?action=getdetail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_ids", runtime.ParamLocationQuery, params.OrderIds); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_ref_ids", runtime.ParamLocationQuery, params.CustomerRefIds); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Customerid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customerid", runtime.ParamLocationQuery, *params.Customerid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignaturev2GetnonceRequest generates requests for Signaturev2Getnonce
func NewSignaturev2GetnonceRequest(server string, params *Signaturev2GetnonceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/signature?action=getnonce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, params.Timestamp); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSleepv2GetRequest generates requests for Sleepv2Get
func NewSleepv2GetRequest(server string, params *Sleepv2GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sleep?action=get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdate", runtime.ParamLocationQuery, params.Startdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddate", runtime.ParamLocationQuery, params.Enddate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DataFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_fields", runtime.ParamLocationQuery, *params.DataFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewSleepv2GetsummaryRequest generates requests for Sleepv2Getsummary
func NewSleepv2GetsummaryRequest(server string, params *Sleepv2GetsummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sleep?action=getsummary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startdateymd", runtime.ParamLocationQuery, params.Startdateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enddateymd", runtime.ParamLocationQuery, params.Enddateymd); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastupdate", runtime.ParamLocationQuery, params.Lastupdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DataFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_fields", runtime.ParamLocationQuery, *params.DataFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewUserv2ActivateRequest generates requests for Userv2Activate
func NewUserv2ActivateRequest(server string, params *Userv2ActivateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=activate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailingpref", runtime.ParamLocationQuery, params.Mailingpref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "birthdate", runtime.ParamLocationQuery, params.Birthdate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "measures", runtime.ParamLocationQuery, params.Measures); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gender", runtime.ParamLocationQuery, params.Gender); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preflang", runtime.ParamLocationQuery, params.Preflang); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_pref", runtime.ParamLocationQuery, params.UnitPref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, params.Timezone); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shortname", runtime.ParamLocationQuery, params.Shortname); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_id", runtime.ParamLocationQuery, params.ExternalId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mac_addresses", runtime.ParamLocationQuery, params.MacAddresses); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Firstname != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firstname", runtime.ParamLocationQuery, *params.Firstname); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Lastname != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastname", runtime.ParamLocationQuery, *params.Lastname); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Phonenumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phonenumber", runtime.ParamLocationQuery, *params.Phonenumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RecoveryCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recovery_code", runtime.ParamLocationQuery, *params.RecoveryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Goals != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "goals", runtime.ParamLocationQuery, *params.Goals); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserv2GetRequest generates requests for Userv2Get
func NewUserv2GetRequest(server string, params *Userv2GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, params.Nonce); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signature", runtime.ParamLocationQuery, params.Signature); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserv2GetdeviceRequest generates requests for Userv2Getdevice
func NewUserv2GetdeviceRequest(server string, params *Userv2GetdeviceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=getdevice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewUserv2GetgoalsRequest generates requests for Userv2Getgoals
func NewUserv2GetgoalsRequest(server string, params *Userv2GetgoalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=getgoals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewUserv2LinkRequest generates requests for Userv2Link
func NewUserv2LinkRequest(server string, params *Userv2LinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mac_addresses", runtime.ParamLocationQuery, params.MacAddresses); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

// NewUserv2UnlinkRequest generates requests for Userv2Unlink
func NewUserv2UnlinkRequest(server string, params *Userv2UnlinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/user?action=unlink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mac_address", runtime.ParamLocationQuery, params.MacAddress); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// MeasureGetmeas request
	MeasureGetmeasWithResponse(ctx context.Context, params *MeasureGetmeasParams, reqEditors ...RequestEditorFn) (*MeasureGetmeasResponse, error)

	// NotifyGet request
	NotifyGetWithResponse(ctx context.Context, params *NotifyGetParams, reqEditors ...RequestEditorFn) (*NotifyGetResponse, error)

	// NotifyList request
	NotifyListWithResponse(ctx context.Context, params *NotifyListParams, reqEditors ...RequestEditorFn) (*NotifyListResponse, error)

	// NotifyRevoke request
	NotifyRevokeWithResponse(ctx context.Context, params *NotifyRevokeParams, reqEditors ...RequestEditorFn) (*NotifyRevokeResponse, error)

	// NotifySubscribe request
	NotifySubscribeWithResponse(ctx context.Context, params *NotifySubscribeParams, reqEditors ...RequestEditorFn) (*NotifySubscribeResponse, error)

	// NotifyUpdate request
	NotifyUpdateWithResponse(ctx context.Context, params *NotifyUpdateParams, reqEditors ...RequestEditorFn) (*NotifyUpdateResponse, error)

	// Oauth2Authorize request
	Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResponse, error)

	// Dropshipmentv2Createorder request
	Dropshipmentv2CreateorderWithResponse(ctx context.Context, params *Dropshipmentv2CreateorderParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2CreateorderResponse, error)

	// Dropshipmentv2Createuserorder request
	Dropshipmentv2CreateuserorderWithResponse(ctx context.Context, params *Dropshipmentv2CreateuserorderParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2CreateuserorderResponse, error)

	// Dropshipmentv2Delete request
	Dropshipmentv2DeleteWithResponse(ctx context.Context, params *Dropshipmentv2DeleteParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2DeleteResponse, error)

	// Dropshipmentv2Getorderstatus request
	Dropshipmentv2GetorderstatusWithResponse(ctx context.Context, params *Dropshipmentv2GetorderstatusParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2GetorderstatusResponse, error)

	// Dropshipmentv2Update request
	Dropshipmentv2UpdateWithResponse(ctx context.Context, params *Dropshipmentv2UpdateParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2UpdateResponse, error)

	// Heartv2Get request
	Heartv2GetWithResponse(ctx context.Context, params *Heartv2GetParams, reqEditors ...RequestEditorFn) (*Heartv2GetResponse, error)

	// Heartv2List request
	Heartv2ListWithResponse(ctx context.Context, params *Heartv2ListParams, reqEditors ...RequestEditorFn) (*Heartv2ListResponse, error)

	// Measurev2Getintradayactivity request
	Measurev2GetintradayactivityWithResponse(ctx context.Context, params *Measurev2GetintradayactivityParams, reqEditors ...RequestEditorFn) (*Measurev2GetintradayactivityResponse, error)

	// Measurev2Getactivity request
	Measurev2GetactivityWithResponse(ctx context.Context, params *Measurev2GetactivityParams, reqEditors ...RequestEditorFn) (*Measurev2GetactivityResponse, error)

	// Measurev2Getworkouts request
	Measurev2GetworkoutsWithResponse(ctx context.Context, params *Measurev2GetworkoutsParams, reqEditors ...RequestEditorFn) (*Measurev2GetworkoutsResponse, error)

	// Oauth2Getdemoaccess request
	Oauth2GetdemoaccessWithResponse(ctx context.Context, params *Oauth2GetdemoaccessParams, reqEditors ...RequestEditorFn) (*Oauth2GetdemoaccessResponse, error)

	// Oauth2Recoverauthorizationcode request
	Oauth2RecoverauthorizationcodeWithResponse(ctx context.Context, params *Oauth2RecoverauthorizationcodeParams, reqEditors ...RequestEditorFn) (*Oauth2RecoverauthorizationcodeResponse, error)

	// Oauth2Refreshaccesstoken request
	Oauth2RefreshaccesstokenWithResponse(ctx context.Context, params *Oauth2RefreshaccesstokenParams, reqEditors ...RequestEditorFn) (*Oauth2RefreshaccesstokenResponse, error)

	// Oauth2Getaccesstoken request
	Oauth2GetaccesstokenWithResponse(ctx context.Context, params *Oauth2GetaccesstokenParams, reqEditors ...RequestEditorFn) (*Oauth2GetaccesstokenResponse, error)

	// Orderv2Getdetail request
	Orderv2GetdetailWithResponse(ctx context.Context, params *Orderv2GetdetailParams, reqEditors ...RequestEditorFn) (*Orderv2GetdetailResponse, error)

	// Signaturev2Getnonce request
	Signaturev2GetnonceWithResponse(ctx context.Context, params *Signaturev2GetnonceParams, reqEditors ...RequestEditorFn) (*Signaturev2GetnonceResponse, error)

	// Sleepv2Get request
	Sleepv2GetWithResponse(ctx context.Context, params *Sleepv2GetParams, reqEditors ...RequestEditorFn) (*Sleepv2GetResponse, error)

	// Sleepv2Getsummary request
	Sleepv2GetsummaryWithResponse(ctx context.Context, params *Sleepv2GetsummaryParams, reqEditors ...RequestEditorFn) (*Sleepv2GetsummaryResponse, error)

	// Userv2Activate request
	Userv2ActivateWithResponse(ctx context.Context, params *Userv2ActivateParams, reqEditors ...RequestEditorFn) (*Userv2ActivateResponse, error)

	// Userv2Get request
	Userv2GetWithResponse(ctx context.Context, params *Userv2GetParams, reqEditors ...RequestEditorFn) (*Userv2GetResponse, error)

	// Userv2Getdevice request
	Userv2GetdeviceWithResponse(ctx context.Context, params *Userv2GetdeviceParams, reqEditors ...RequestEditorFn) (*Userv2GetdeviceResponse, error)

	// Userv2Getgoals request
	Userv2GetgoalsWithResponse(ctx context.Context, params *Userv2GetgoalsParams, reqEditors ...RequestEditorFn) (*Userv2GetgoalsResponse, error)

	// Userv2Link request
	Userv2LinkWithResponse(ctx context.Context, params *Userv2LinkParams, reqEditors ...RequestEditorFn) (*Userv2LinkResponse, error)

	// Userv2Unlink request
	Userv2UnlinkWithResponse(ctx context.Context, params *Userv2UnlinkParams, reqEditors ...RequestEditorFn) (*Userv2UnlinkResponse, error)
}

type MeasureGetmeasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// For every measure/measurement made, a measure group is created. The measure group purpose is to group together measures that have been taken at the same time. For instance, when measuring blood pressure you will have a measure group with a systole measure, a diastole measure, and a heartrate measure. Every time a measure is create/updated/deleted, the corresponding measure group is updated.
			Measuregrps *[]MeasuregrpObject `json:"measuregrps,omitempty"`

			// To know if there is more data to fetch or not.
			More *int `json:"more,omitempty"`

			// Offset to use to retrieve the next data.
			Offset *int `json:"offset,omitempty"`

			// Timezone for the date.
			Timezone *string `json:"timezone,omitempty"`

			// Server time at which the answer was generated.
			Updatetime *string `json:"updatetime,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeasureGetmeasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeasureGetmeasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know the meaning of each values.
			Appli *int `json:"appli,omitempty"`

			// Callback url of the notification.
			Callbackurl *string `json:"callbackurl,omitempty"`

			// Comment entered when creating the notification configuration.
			Comment *string `json:"comment,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NotifyGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// List of notification configurations for this user.
			Profiles *[]NotifyObject `json:"profiles,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NotifyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *map[string]interface{} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NotifyRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifySubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *map[string]interface{} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NotifySubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifySubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotifyUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *map[string]interface{} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NotifyUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotifyUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Dropshipmentv2CreateorderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// References of the orders with invalid address. *(Only if at least one order has an invalid address)*
			InvalidAddressCustomerRefIds *[]string `json:"invalid_address_customer_ref_ids,omitempty"`

			// List of created orders. *(Only if orders were successfully created)*
			Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Dropshipmentv2CreateorderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Dropshipmentv2CreateorderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Dropshipmentv2CreateuserorderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// References of the orders with invalid address. *(Only if at least one order has an invalid address)*
			InvalidAddressCustomerRefIds *[]string `json:"invalid_address_customer_ref_ids,omitempty"`

			// List of created orders. *(Only if orders were successfully created)*
			Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
			User   *struct {
				// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
				Code *string `json:"code,omitempty"`

				// Unique identifier used by partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/).
				ExternalId *string `json:"external_id,omitempty"`
			} `json:"user,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Dropshipmentv2CreateuserorderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Dropshipmentv2CreateuserorderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Dropshipmentv2DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *map[string]interface{} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Dropshipmentv2DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Dropshipmentv2DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Dropshipmentv2GetorderstatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Orders *[]DropshipmentGetOrderStatusObject `json:"orders,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Dropshipmentv2GetorderstatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Dropshipmentv2GetorderstatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Dropshipmentv2UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Dropshipmentv2UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Dropshipmentv2UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Heartv2GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// Signal Sampling Frequency (Hz).
			SamplingFrequency *int `json:"sampling_frequency,omitempty"`

			// Signal value in micro-volt (μV).
			Signal *[]int `json:"signal,omitempty"`

			// Where the user is wearing the device.
			//
			//
			// | Value | Description|
			// |---|---|
			// |0 | Right Wrist|
			// |1 | Left Wrist|
			// |2 | Right Arm|
			// |3 | Left Arm|
			// |4 | Right Foot|
			// |5 | Left Foot|
			// |6 | Between Legs|
			// |8 | Left part of the body|
			// |9 | Right part of the body|
			// |10 | Left leg|
			// |11 | Right leg|
			// |12 | Torso|
			Wearposition *int `json:"wearposition,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Heartv2GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Heartv2GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Heartv2ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// To know if there is more data to fetch or not.
			More *bool `json:"more,omitempty"`

			// Offset to use to retrieve the next data.
			Offset *int                      `json:"offset,omitempty"`
			Series *[]HeartMeasurementObject `json:"series,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Heartv2ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Heartv2ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Measurev2GetintradayactivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Series *struct {
				// $timestamp represents the epoch value of the intraday data
				Timestamp *struct {
					// Estimation of active calories burned (in Kcal). *(Use 'data_fields' to request this data.)*
					Calories *float32 `json:"calories,omitempty"`

					// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
					Deviceid *string `json:"deviceid,omitempty"`

					// Distance travelled (in meters). *(Use 'data_fields' to request this data.)*
					Distance *float32 `json:"distance,omitempty"`

					// Duration of the activity (in seconds). *(Use 'data_fields' to request this data.)*
					Duration *int `json:"duration,omitempty"`

					// Number of floors climbed. *(Use 'data_fields' to request this data.)*
					Elevation *float32 `json:"elevation,omitempty"`

					// Measured heart rate. *(Use 'data_fields' to request this data.)*
					HeartRate *int `json:"heart_rate,omitempty"`

					// Device model. Value can be:
					//
					//
					// | Value | Description|
					// |---|---|
					// |Withings WBS01 | Scale|
					// |WS30 | Scale|
					// |Kid Scale | Scale|
					// |Smart Body Analyzer | Scale|
					// |Body+ | Scale|
					// |Body Cardio | Scale|
					// |Body | Scale|
					// |WBS08 | Scale|
					// |Body Pro | Scale|
					// |WBS10 | Scale|
					// |WBS11 | Scale|
					// |Smart Baby Monitor | Babyphone|
					// |Withings Home | Babyphone|
					// |Withings Blood Pressure Monitor V1 | Blood Pressure Monitor|
					// |Withings Blood Pressure Monitor V2 | Blood Pressure Monitor|
					// |Withings Blood Pressure Monitor V3 | Blood Pressure Monitor|
					// |BPM Core | Blood Pressure Monitor|
					// |BPM Connect | Blood Pressure Monitor|
					// |BPM Connect Pro | Blood Pressure Monitor|
					// |Pulse | Activity Tracker|
					// |Activite | Activity Tracker|
					// |Activite (Pop, Steel) | Activity Tracker|
					// |Withings Go | Activity Tracker|
					// |Activite Steel HR | Activity Tracker|
					// |Activite Steel HR Sport Edition | Activity Tracker|
					// |Pulse HR | Activity Tracker|
					// |Move | Activity Tracker|
					// |Move ECG | Activity Tracker|
					// |ScanWatch | Activity Tracker|
					// |Aura Dock | Sleep Monitor|
					// |Aura Sensor | Sleep Monitor|
					// |Aura Sensor V2 | Sleep Monitor|
					// |Thermo | Smart Connected Thermometer|
					// |WUP01 | Gateway|
					Model *string `json:"model,omitempty"`

					//
					//
					// | Value | Description|
					// |---|---|
					// |1 | Withings WBS01|
					// |2 | WS30|
					// |3 | Kid Scale|
					// |4 | Smart Body Analyzer|
					// |5 | Body+|
					// |6 | Body Cardio|
					// |7 | Body|
					// |10 | WBS08|
					// |9 | Body Pro|
					// |11 | WBS10|
					// |12 | WBS11|
					// |21 | Smart Baby Monitor|
					// |22 | Withings Home|
					// |41 | Withings Blood Pressure Monitor V1|
					// |42 | Withings Blood Pressure Monitor V2|
					// |43 | Withings Blood Pressure Monitor V3|
					// |44 | BPM Core|
					// |45 | BPM Connect|
					// |46 | BPM Connect Pro|
					// |51 | Pulse|
					// |52 | Activite|
					// |53 | Activite (Pop, Steel)|
					// |54 | Withings Go|
					// |55 | Activite Steel HR|
					// |59 | Activite Steel HR Sport Edition|
					// |58 | Pulse HR|
					// |90 | Move|
					// |91 | Move ECG|
					// |92 | Move ECG|
					// |93 | ScanWatch|
					// |60 | Aura Dock|
					// |61 | Aura Sensor|
					// |63 | Aura Sensor V2|
					// |70 | Thermo|
					// |100 | WUP01|
					ModelId *int `json:"model_id,omitempty"`

					// Number of pool_lap performed. *(Use 'data_fields' to request this data.)*
					PoolLap *int `json:"pool_lap,omitempty"`

					// SpO2 measurement automatically tracked by a device tracker
					Spo2Auto *float32 `json:"spo2_auto,omitempty"`

					// Number of steps. *(Use 'data_fields' to request this data.)*
					Steps *int `json:"steps,omitempty"`

					// Number of strokes performed. *(Use 'data_fields' to request this data.)*
					Stroke *int `json:"stroke,omitempty"`
				} `json:"$timestamp,omitempty"`
			} `json:"series,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Measurev2GetintradayactivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Measurev2GetintradayactivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Measurev2GetactivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Activities *[]ActivityObject `json:"activities,omitempty"`

			// To know if there is more data to fetch or not.
			More *bool `json:"more,omitempty"`

			// Offset to use to retrieve the next data.
			Offset *int `json:"offset,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Measurev2GetactivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Measurev2GetactivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Measurev2GetworkoutsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// To know if there is more data to fetch or not.
			More *bool `json:"more,omitempty"`

			// Offset to use to retrieve the next data.
			Offset *int             `json:"offset,omitempty"`
			Series *[]WorkoutObject `json:"series,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Measurev2GetworkoutsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Measurev2GetworkoutsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2GetdemoaccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// Your new Access Token.
			AccessToken *string `json:"access_token,omitempty"`

			// Access token expiry delay in seconds.
			ExpiresIn *int `json:"expires_in,omitempty"`

			// Your Refresh Token.
			RefreshToken *string `json:"refresh_token,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Oauth2GetdemoaccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2GetdemoaccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2RecoverauthorizationcodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			User *struct {
				// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
				Code *string `json:"code,omitempty"`
			} `json:"user,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Oauth2RecoverauthorizationcodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2RecoverauthorizationcodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2RefreshaccesstokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// Your new Access Token.
			AccessToken *string `json:"access_token,omitempty"`
			CsrfToken   *string `json:"csrf_token,omitempty"`

			// Access token expiry delay in seconds.
			ExpiresIn *int `json:"expires_in,omitempty"`

			// Your Refresh Token.
			RefreshToken *string `json:"refresh_token,omitempty"`

			// You can get only the scope that the user accepted with the Token you have. Scopes can be 'user.info' 'user.metrics' 'user.activity' 'user.sleepevents'  and must be separated by a coma.
			Scope *string `json:"scope,omitempty"`

			// HTTP Authorization Header format: Bearer
			TokenType *string `json:"token_type,omitempty"`

			// The id of the user.
			Userid *string `json:"userid,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Oauth2RefreshaccesstokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2RefreshaccesstokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2GetaccesstokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// Your new Access Token.
			AccessToken *string `json:"access_token,omitempty"`
			CsrfToken   *string `json:"csrf_token,omitempty"`

			// Access token expiry delay in seconds.
			ExpiresIn *int `json:"expires_in,omitempty"`

			// Your Refresh Token.
			RefreshToken *string `json:"refresh_token,omitempty"`

			// You can get only the scope that the user accepted with the Token you have. Scopes can be 'user.info' 'user.metrics' 'user.activity' 'user.sleepevents'  and must be separated by a coma.
			Scope *string `json:"scope,omitempty"`

			// HTTP Authorization Header format: Bearer
			TokenType *string `json:"token_type,omitempty"`

			// The id of the user.
			Userid *string `json:"userid,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Oauth2GetaccesstokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2GetaccesstokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Orderv2GetdetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Orders *[]DropshipmentGetOrderStatusObject `json:"orders,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Orderv2GetdetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Orderv2GetdetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Signaturev2GetnonceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// A random timestamp based token to be used once in requiring signature API services to avoid replay attack
			Nonce *string `json:"nonce,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Signaturev2GetnonceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Signaturev2GetnonceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sleepv2GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Series *struct {
				// The end datetime for the sleep data. A single call can span up to 7 days maximum. To cover a wider time range, you will need to perform multiple calls.
				Enddate *int64 `json:"enddate,omitempty"`

				// Heart Rate. *(Use 'data_fields' to request this data.)*
				Hr *struct {
					// $timestamp represents the epoch value of the heart rate data, value of this key will be the heart rate data
					Timestamp *int `json:"$timestamp,omitempty"`
				} `json:"hr,omitempty"`

				// Device model. Value can be:
				//
				//
				// | Value | Description|
				// |---|---|
				// |Aura Dock | Sleep Monitor|
				// |Aura Sensor | Sleep Monitor|
				// |Aura Sensor V2 | Sleep Monitor|
				// |Pulse | Activity Tracker|
				// |Activite | Activity Tracker|
				// |Activite (Pop, Steel) | Activity Tracker|
				// |Withings Go | Activity Tracker|
				// |Activite Steel HR | Activity Tracker|
				// |Activite Steel HR Sport Edition | Activity Tracker|
				// |Pulse HR | Activity Tracker|
				// |Move | Activity Tracker|
				// |Move ECG | Activity Tracker|
				// |ScanWatch | Activity Tracker|
				Model *string `json:"model,omitempty"`

				//
				//
				// | Value | Description|
				// |---|---|
				// |60 | Aura Dock|
				// |61 | Aura Sensor|
				// |63 | Aura Sensor V2|
				// |51 | Pulse|
				// |52 | Activite|
				// |53 | Activite (Pop, Steel)|
				// |54 | Withings Go|
				// |55 | Activite Steel HR|
				// |59 | Activite Steel HR Sport Edition|
				// |58 | Pulse HR|
				// |90 | Move|
				// |91 | Move ECG|
				// |92 | Move ECG|
				// |93 | ScanWatch|
				ModelId *int `json:"model_id,omitempty"`

				// Heart rate variability - Root mean square of the successive differences over "a few seconds"
				Rmssd *struct {
					Timestamp *int `json:"$timestamp,omitempty"`
				} `json:"rmssd,omitempty"`

				// Respiration Rate. *(Use 'data_fields' to request this data.)*
				Rr *struct {
					// $timestamp represents the epoch value of the respiration rate data, value of this key will be the respiration rate data
					Timestamp *int `json:"$timestamp,omitempty"`
				} `json:"rr,omitempty"`

				// Heart rate variability - Standard deviation of the NN over 1 minute
				Sdnn1 *struct {
					Timestamp *int `json:"$timestamp,omitempty"`
				} `json:"sdnn_1,omitempty"`

				// Total snoring time
				Snoring *struct {
					Timestamp *int `json:"$timestamp,omitempty"`
				} `json:"snoring,omitempty"`

				// The starting datetime for the sleep state data.
				Startdate *int64 `json:"startdate,omitempty"`

				// The state of sleeping. Values can be:
				//
				//
				// | Value | Description|
				// |---|---|
				// |0 | Sleep state awake|
				// |1 | Sleep state light|
				// |2 | Sleep state deep|
				// |3 | Sleep state rem|
				// |4 | Sleep manual|
				// |5 | Sleep unspecified|
				State *int `json:"state,omitempty"`
			} `json:"series,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Sleepv2GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sleepv2GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Sleepv2GetsummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			// To know if there is more data to fetch or not.
			More *bool `json:"more,omitempty"`

			// Offset to use to retrieve the next data.
			Offset *int `json:"offset,omitempty"`
			Series *[]struct {
				Created *int64 `json:"created,omitempty"`

				// Details of sleep.
				Data *struct {
					// Medical grade AHI. Only available for devices purchased in Europe and Australia, with the sleep apnea detection feature activated. Average number of hypopnea and apnea episodes per hour, that occured during sleep time.
					ApneaHypopneaIndex *int `json:"apnea_hypopnea_index,omitempty"`

					// Duration of sleep when night comes from external source (light, deep and rem sleep durations are null in this case). *(Use 'data_fields' to request this data.)*
					Asleepduration *int `json:"asleepduration,omitempty"`

					// Wellness metric, available for all Sleep and Sleep Analyzer devices. Intensity of <a href='/api-reference/#section/Glossary'>breathing disturbances</a>
					BreathingDisturbancesIntensity *int `json:"breathing_disturbances_intensity,omitempty"`

					// Duration in state deep sleep (in seconds). *(Use 'data_fields' to request this data.)*
					Deepsleepduration *int `json:"deepsleepduration,omitempty"`

					// Time to sleep (in seconds). (deprecated) *(Use 'data_fields' to request this data.)*
					Durationtosleep *int `json:"durationtosleep,omitempty"`

					// Time to wake up (in seconds). (deprecated) *(Use 'data_fields' to request this data.)*
					Durationtowakeup *int `json:"durationtowakeup,omitempty"`

					// Average heart rate. *(Use 'data_fields' to request this data.)*
					HrAverage *int `json:"hr_average,omitempty"`

					// Maximal heart rate. *(Use 'data_fields' to request this data.)*
					HrMax *int `json:"hr_max,omitempty"`

					// Minimal heart rate. *(Use 'data_fields' to request this data.)*
					HrMin *int `json:"hr_min,omitempty"`

					// Duration in state light sleep (in seconds). *(Use 'data_fields' to request this data.)*
					Lightsleepduration *int `json:"lightsleepduration,omitempty"`

					// Count of the REM sleep phases. *(Use 'data_fields' to request this data.)*
					NbRemEpisodes *int `json:"nb_rem_episodes,omitempty"`

					// Events list happened during the night
					NightEvents json.RawMessage `json:"night_events,omitempty"`

					// Number of times the user got out of bed during the night. *(Use 'data_fields' to request this data.)*
					OutOfBedCount *int `json:"out_of_bed_count,omitempty"`

					// Duration in state REM sleep (in seconds). *(Use 'data_fields' to request this data.)*
					Remsleepduration *int `json:"remsleepduration,omitempty"`

					// Average respiration rate. *(Use 'data_fields' to request this data.)*
					RrAverage *int `json:"rr_average,omitempty"`

					// Maximal respiration rate. *(Use 'data_fields' to request this data.)*
					RrMax *int `json:"rr_max,omitempty"`

					// Minimal respiration rate. *(Use 'data_fields' to request this data.)*
					RrMin *int `json:"rr_min,omitempty"`

					// Ratio of the total sleep time over the time spent in bed. *(Use 'data_fields' to request this data.)*
					SleepEfficiency *float32 `json:"sleep_efficiency,omitempty"`

					// Time spent in bed before falling asleep. *(Use 'data_fields' to request this data.)*
					SleepLatency *int `json:"sleep_latency,omitempty"`

					// Sleep score
					SleepScore *int `json:"sleep_score,omitempty"`

					// Total snoring time
					Snoring *int `json:"snoring,omitempty"`

					// Numbers of snoring episodes of at least one minute
					Snoringepisodecount *int `json:"snoringepisodecount,omitempty"`

					// Total time spent asleep. Sum of light, deep and rem durations. *(Use 'data_fields' to request this data.)*
					TotalSleepTime *int `json:"total_sleep_time,omitempty"`

					// Total time spent in bed. *(Use 'data_fields' to request this data.)*
					TotalTimeinbed *int `json:"total_timeinbed,omitempty"`

					// Time spent in bed after waking up. *(Use 'data_fields' to request this data.)*
					WakeupLatency *int `json:"wakeup_latency,omitempty"`

					// Number of times the user woke up while in bed. Does not include the number of times the user got out of bed. *(Use 'data_fields' to request this data.)*
					Wakeupcount *int `json:"wakeupcount,omitempty"`

					// Time spent awake (in seconds). *(Use 'data_fields' to request this data.)*
					Wakeupduration *int `json:"wakeupduration,omitempty"`

					// Time spent awake in bed after falling asleep for the 1st time during the night. *(Use 'data_fields' to request this data.)*
					Waso *int `json:"waso,omitempty"`
				} `json:"data,omitempty"`

				// Date at which the measure was taken or entered.
				Date *string `json:"date,omitempty"`

				// The end datetime for the sleep data. A single call can span up to 7 days maximum. To cover a wider time range, you will need to perform multiple calls.
				Enddate *int64 `json:"enddate,omitempty"`

				// The source for sleep data. Value can be 16 for a tracker or 32 for a Sleep Monitor.
				Model *int `json:"model,omitempty"`

				//
				//
				// | Value | Description|
				// |---|---|
				// |60 | Aura Dock|
				// |61 | Aura Sensor|
				// |63 | Aura Sensor V2|
				// |51 | Pulse|
				// |52 | Activite|
				// |53 | Activite (Pop, Steel)|
				// |54 | Withings Go|
				// |55 | Activite Steel HR|
				// |59 | Activite Steel HR Sport Edition|
				// |58 | Pulse HR|
				// |90 | Move|
				// |91 | Move ECG|
				// |92 | Move ECG|
				// |93 | ScanWatch|
				ModelId *int `json:"model_id,omitempty"`

				// The timestamp of the last modification.
				Modified *int64 `json:"modified,omitempty"`

				// The starting datetime for the sleep state data.
				Startdate *int64 `json:"startdate,omitempty"`

				// Timezone for the date.
				Timezone *string `json:"timezone,omitempty"`
			} `json:"series,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Sleepv2GetsummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Sleepv2GetsummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2ActivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Devices *[]UserDeviceMacObject `json:"devices,omitempty"`
			User    *struct {
				// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
				Code *string `json:"code,omitempty"`

				// Unique identifier used by partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/).
				ExternalId *string `json:"external_id,omitempty"`
			} `json:"user,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2ActivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2ActivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			User *struct {
				// Unix timestamp of user's birthdate
				Birthdate *int `json:"birthdate,omitempty"`

				// User's email address
				Email *string `json:"email,omitempty"`

				// User's firstname
				Firstname *string `json:"firstname,omitempty"`

				// User's gender (0: man, 1: woman)
				Gender *int `json:"gender,omitempty"`

				// User's lastname
				Lastname *string `json:"lastname,omitempty"`

				// User consent to receiving sales and marketing communication from Withings (0: user does not consent, 1: user does consent)
				Mailingpref *bool `json:"mailingpref,omitempty"`

				// User's phone number. *(Only if set)*
				Phonenumber *string `json:"phonenumber,omitempty"`

				// User's language preference. Examples: en_EN / en_US / de_DE / es_ES / fr_FR / it_IT / ja_JA / ko_KR / nl_NL / pt_PT / ru_RU / zh_CN
				Preflang *string `json:"preflang,omitempty"`

				// User's shortname
				Shortname *string `json:"shortname,omitempty"`

				// User's timezone. Examples: "Europe/Paris" / "America/New_York". A complete list of all possible timezones can be found on the "TZ database name" column of this page : https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
				Timezone *string `json:"timezone,omitempty"`

				// User's unit preferences (cf. [Unit preferences](#section/Models/Unit-preferences) model).
				UnitPref *struct {
					Distance    *int `json:"distance,omitempty"`
					Height      *int `json:"height,omitempty"`
					Temperature *int `json:"temperature,omitempty"`
					Weight      *int `json:"weight,omitempty"`
				} `json:"unit_pref,omitempty"`
			} `json:"user,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2GetdeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Devices *[]UserDeviceObject `json:"devices,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2GetdeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2GetdeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2GetgoalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Goals *struct {
				// Sleep duration (in seconds).
				Sleep *int `json:"sleep,omitempty"`

				// Number of steps per day.
				Steps *int `json:"steps,omitempty"`

				// Weight.
				Weight *struct {
					// Power of ten to multiply the ```value``` field to get the real value.<br>Formula: ```value * 10^unit = real value```.<br>Eg: ```value = 20 and unit = -1 => real value = 2```.
					Unit *int `json:"unit,omitempty"`

					// Value for the measure in S.I. units (kilograms, meters etc...). Value should be multiplied by 10 to the power of ```units``` to get the real value.
					Value *int `json:"value,omitempty"`
				} `json:"weight,omitempty"`
			} `json:"goals,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2GetgoalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2GetgoalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2LinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *struct {
			Devices *[]UserDeviceMacObject `json:"devices,omitempty"`
		} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2LinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2LinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Userv2UnlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Response data.
		Body *map[string]interface{} `json:"body,omitempty"`

		// Response status. See <a href='#section/Response-status'>Status</a> section for details.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Userv2UnlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Userv2UnlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// MeasureGetmeasWithResponse request returning *MeasureGetmeasResponse
func (c *ClientWithResponses) MeasureGetmeasWithResponse(ctx context.Context, params *MeasureGetmeasParams, reqEditors ...RequestEditorFn) (*MeasureGetmeasResponse, error) {
	rsp, err := c.MeasureGetmeas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeasureGetmeasResponse(rsp)
}

// NotifyGetWithResponse request returning *NotifyGetResponse
func (c *ClientWithResponses) NotifyGetWithResponse(ctx context.Context, params *NotifyGetParams, reqEditors ...RequestEditorFn) (*NotifyGetResponse, error) {
	rsp, err := c.NotifyGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyGetResponse(rsp)
}

// NotifyListWithResponse request returning *NotifyListResponse
func (c *ClientWithResponses) NotifyListWithResponse(ctx context.Context, params *NotifyListParams, reqEditors ...RequestEditorFn) (*NotifyListResponse, error) {
	rsp, err := c.NotifyList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyListResponse(rsp)
}

// NotifyRevokeWithResponse request returning *NotifyRevokeResponse
func (c *ClientWithResponses) NotifyRevokeWithResponse(ctx context.Context, params *NotifyRevokeParams, reqEditors ...RequestEditorFn) (*NotifyRevokeResponse, error) {
	rsp, err := c.NotifyRevoke(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyRevokeResponse(rsp)
}

// NotifySubscribeWithResponse request returning *NotifySubscribeResponse
func (c *ClientWithResponses) NotifySubscribeWithResponse(ctx context.Context, params *NotifySubscribeParams, reqEditors ...RequestEditorFn) (*NotifySubscribeResponse, error) {
	rsp, err := c.NotifySubscribe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifySubscribeResponse(rsp)
}

// NotifyUpdateWithResponse request returning *NotifyUpdateResponse
func (c *ClientWithResponses) NotifyUpdateWithResponse(ctx context.Context, params *NotifyUpdateParams, reqEditors ...RequestEditorFn) (*NotifyUpdateResponse, error) {
	rsp, err := c.NotifyUpdate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotifyUpdateResponse(rsp)
}

// Oauth2AuthorizeWithResponse request returning *Oauth2AuthorizeResponse
func (c *ClientWithResponses) Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResponse, error) {
	rsp, err := c.Oauth2Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeResponse(rsp)
}

// Dropshipmentv2CreateorderWithResponse request returning *Dropshipmentv2CreateorderResponse
func (c *ClientWithResponses) Dropshipmentv2CreateorderWithResponse(ctx context.Context, params *Dropshipmentv2CreateorderParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2CreateorderResponse, error) {
	rsp, err := c.Dropshipmentv2Createorder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropshipmentv2CreateorderResponse(rsp)
}

// Dropshipmentv2CreateuserorderWithResponse request returning *Dropshipmentv2CreateuserorderResponse
func (c *ClientWithResponses) Dropshipmentv2CreateuserorderWithResponse(ctx context.Context, params *Dropshipmentv2CreateuserorderParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2CreateuserorderResponse, error) {
	rsp, err := c.Dropshipmentv2Createuserorder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropshipmentv2CreateuserorderResponse(rsp)
}

// Dropshipmentv2DeleteWithResponse request returning *Dropshipmentv2DeleteResponse
func (c *ClientWithResponses) Dropshipmentv2DeleteWithResponse(ctx context.Context, params *Dropshipmentv2DeleteParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2DeleteResponse, error) {
	rsp, err := c.Dropshipmentv2Delete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropshipmentv2DeleteResponse(rsp)
}

// Dropshipmentv2GetorderstatusWithResponse request returning *Dropshipmentv2GetorderstatusResponse
func (c *ClientWithResponses) Dropshipmentv2GetorderstatusWithResponse(ctx context.Context, params *Dropshipmentv2GetorderstatusParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2GetorderstatusResponse, error) {
	rsp, err := c.Dropshipmentv2Getorderstatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropshipmentv2GetorderstatusResponse(rsp)
}

// Dropshipmentv2UpdateWithResponse request returning *Dropshipmentv2UpdateResponse
func (c *ClientWithResponses) Dropshipmentv2UpdateWithResponse(ctx context.Context, params *Dropshipmentv2UpdateParams, reqEditors ...RequestEditorFn) (*Dropshipmentv2UpdateResponse, error) {
	rsp, err := c.Dropshipmentv2Update(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropshipmentv2UpdateResponse(rsp)
}

// Heartv2GetWithResponse request returning *Heartv2GetResponse
func (c *ClientWithResponses) Heartv2GetWithResponse(ctx context.Context, params *Heartv2GetParams, reqEditors ...RequestEditorFn) (*Heartv2GetResponse, error) {
	rsp, err := c.Heartv2Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartv2GetResponse(rsp)
}

// Heartv2ListWithResponse request returning *Heartv2ListResponse
func (c *ClientWithResponses) Heartv2ListWithResponse(ctx context.Context, params *Heartv2ListParams, reqEditors ...RequestEditorFn) (*Heartv2ListResponse, error) {
	rsp, err := c.Heartv2List(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartv2ListResponse(rsp)
}

// Measurev2GetintradayactivityWithResponse request returning *Measurev2GetintradayactivityResponse
func (c *ClientWithResponses) Measurev2GetintradayactivityWithResponse(ctx context.Context, params *Measurev2GetintradayactivityParams, reqEditors ...RequestEditorFn) (*Measurev2GetintradayactivityResponse, error) {
	rsp, err := c.Measurev2Getintradayactivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeasurev2GetintradayactivityResponse(rsp)
}

// Measurev2GetactivityWithResponse request returning *Measurev2GetactivityResponse
func (c *ClientWithResponses) Measurev2GetactivityWithResponse(ctx context.Context, params *Measurev2GetactivityParams, reqEditors ...RequestEditorFn) (*Measurev2GetactivityResponse, error) {
	rsp, err := c.Measurev2Getactivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeasurev2GetactivityResponse(rsp)
}

// Measurev2GetworkoutsWithResponse request returning *Measurev2GetworkoutsResponse
func (c *ClientWithResponses) Measurev2GetworkoutsWithResponse(ctx context.Context, params *Measurev2GetworkoutsParams, reqEditors ...RequestEditorFn) (*Measurev2GetworkoutsResponse, error) {
	rsp, err := c.Measurev2Getworkouts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeasurev2GetworkoutsResponse(rsp)
}

// Oauth2GetdemoaccessWithResponse request returning *Oauth2GetdemoaccessResponse
func (c *ClientWithResponses) Oauth2GetdemoaccessWithResponse(ctx context.Context, params *Oauth2GetdemoaccessParams, reqEditors ...RequestEditorFn) (*Oauth2GetdemoaccessResponse, error) {
	rsp, err := c.Oauth2Getdemoaccess(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2GetdemoaccessResponse(rsp)
}

// Oauth2RecoverauthorizationcodeWithResponse request returning *Oauth2RecoverauthorizationcodeResponse
func (c *ClientWithResponses) Oauth2RecoverauthorizationcodeWithResponse(ctx context.Context, params *Oauth2RecoverauthorizationcodeParams, reqEditors ...RequestEditorFn) (*Oauth2RecoverauthorizationcodeResponse, error) {
	rsp, err := c.Oauth2Recoverauthorizationcode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2RecoverauthorizationcodeResponse(rsp)
}

// Oauth2RefreshaccesstokenWithResponse request returning *Oauth2RefreshaccesstokenResponse
func (c *ClientWithResponses) Oauth2RefreshaccesstokenWithResponse(ctx context.Context, params *Oauth2RefreshaccesstokenParams, reqEditors ...RequestEditorFn) (*Oauth2RefreshaccesstokenResponse, error) {
	rsp, err := c.Oauth2Refreshaccesstoken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2RefreshaccesstokenResponse(rsp)
}

// Oauth2GetaccesstokenWithResponse request returning *Oauth2GetaccesstokenResponse
func (c *ClientWithResponses) Oauth2GetaccesstokenWithResponse(ctx context.Context, params *Oauth2GetaccesstokenParams, reqEditors ...RequestEditorFn) (*Oauth2GetaccesstokenResponse, error) {
	rsp, err := c.Oauth2Getaccesstoken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2GetaccesstokenResponse(rsp)
}

// Orderv2GetdetailWithResponse request returning *Orderv2GetdetailResponse
func (c *ClientWithResponses) Orderv2GetdetailWithResponse(ctx context.Context, params *Orderv2GetdetailParams, reqEditors ...RequestEditorFn) (*Orderv2GetdetailResponse, error) {
	rsp, err := c.Orderv2Getdetail(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderv2GetdetailResponse(rsp)
}

// Signaturev2GetnonceWithResponse request returning *Signaturev2GetnonceResponse
func (c *ClientWithResponses) Signaturev2GetnonceWithResponse(ctx context.Context, params *Signaturev2GetnonceParams, reqEditors ...RequestEditorFn) (*Signaturev2GetnonceResponse, error) {
	rsp, err := c.Signaturev2Getnonce(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignaturev2GetnonceResponse(rsp)
}

// Sleepv2GetWithResponse request returning *Sleepv2GetResponse
func (c *ClientWithResponses) Sleepv2GetWithResponse(ctx context.Context, params *Sleepv2GetParams, reqEditors ...RequestEditorFn) (*Sleepv2GetResponse, error) {
	rsp, err := c.Sleepv2Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSleepv2GetResponse(rsp)
}

// Sleepv2GetsummaryWithResponse request returning *Sleepv2GetsummaryResponse
func (c *ClientWithResponses) Sleepv2GetsummaryWithResponse(ctx context.Context, params *Sleepv2GetsummaryParams, reqEditors ...RequestEditorFn) (*Sleepv2GetsummaryResponse, error) {
	rsp, err := c.Sleepv2Getsummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSleepv2GetsummaryResponse(rsp)
}

// Userv2ActivateWithResponse request returning *Userv2ActivateResponse
func (c *ClientWithResponses) Userv2ActivateWithResponse(ctx context.Context, params *Userv2ActivateParams, reqEditors ...RequestEditorFn) (*Userv2ActivateResponse, error) {
	rsp, err := c.Userv2Activate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2ActivateResponse(rsp)
}

// Userv2GetWithResponse request returning *Userv2GetResponse
func (c *ClientWithResponses) Userv2GetWithResponse(ctx context.Context, params *Userv2GetParams, reqEditors ...RequestEditorFn) (*Userv2GetResponse, error) {
	rsp, err := c.Userv2Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2GetResponse(rsp)
}

// Userv2GetdeviceWithResponse request returning *Userv2GetdeviceResponse
func (c *ClientWithResponses) Userv2GetdeviceWithResponse(ctx context.Context, params *Userv2GetdeviceParams, reqEditors ...RequestEditorFn) (*Userv2GetdeviceResponse, error) {
	rsp, err := c.Userv2Getdevice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2GetdeviceResponse(rsp)
}

// Userv2GetgoalsWithResponse request returning *Userv2GetgoalsResponse
func (c *ClientWithResponses) Userv2GetgoalsWithResponse(ctx context.Context, params *Userv2GetgoalsParams, reqEditors ...RequestEditorFn) (*Userv2GetgoalsResponse, error) {
	rsp, err := c.Userv2Getgoals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2GetgoalsResponse(rsp)
}

// Userv2LinkWithResponse request returning *Userv2LinkResponse
func (c *ClientWithResponses) Userv2LinkWithResponse(ctx context.Context, params *Userv2LinkParams, reqEditors ...RequestEditorFn) (*Userv2LinkResponse, error) {
	rsp, err := c.Userv2Link(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2LinkResponse(rsp)
}

// Userv2UnlinkWithResponse request returning *Userv2UnlinkResponse
func (c *ClientWithResponses) Userv2UnlinkWithResponse(ctx context.Context, params *Userv2UnlinkParams, reqEditors ...RequestEditorFn) (*Userv2UnlinkResponse, error) {
	rsp, err := c.Userv2Unlink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserv2UnlinkResponse(rsp)
}

// ParseMeasureGetmeasResponse parses an HTTP response from a MeasureGetmeasWithResponse call
func ParseMeasureGetmeasResponse(rsp *http.Response) (*MeasureGetmeasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeasureGetmeasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// For every measure/measurement made, a measure group is created. The measure group purpose is to group together measures that have been taken at the same time. For instance, when measuring blood pressure you will have a measure group with a systole measure, a diastole measure, and a heartrate measure. Every time a measure is create/updated/deleted, the corresponding measure group is updated.
				Measuregrps *[]MeasuregrpObject `json:"measuregrps,omitempty"`

				// To know if there is more data to fetch or not.
				More *int `json:"more,omitempty"`

				// Offset to use to retrieve the next data.
				Offset *int `json:"offset,omitempty"`

				// Timezone for the date.
				Timezone *string `json:"timezone,omitempty"`

				// Server time at which the answer was generated.
				Updatetime *string `json:"updatetime,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotifyGetResponse parses an HTTP response from a NotifyGetWithResponse call
func ParseNotifyGetResponse(rsp *http.Response) (*NotifyGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// Refer to the [Notifications section](/developer-guide/v3/data-api/keep-user-data-up-to-date/) to know the meaning of each values.
				Appli *int `json:"appli,omitempty"`

				// Callback url of the notification.
				Callbackurl *string `json:"callbackurl,omitempty"`

				// Comment entered when creating the notification configuration.
				Comment *string `json:"comment,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotifyListResponse parses an HTTP response from a NotifyListWithResponse call
func ParseNotifyListResponse(rsp *http.Response) (*NotifyListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// List of notification configurations for this user.
				Profiles *[]NotifyObject `json:"profiles,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotifyRevokeResponse parses an HTTP response from a NotifyRevokeWithResponse call
func ParseNotifyRevokeResponse(rsp *http.Response) (*NotifyRevokeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *map[string]interface{} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotifySubscribeResponse parses an HTTP response from a NotifySubscribeWithResponse call
func ParseNotifySubscribeResponse(rsp *http.Response) (*NotifySubscribeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifySubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *map[string]interface{} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNotifyUpdateResponse parses an HTTP response from a NotifyUpdateWithResponse call
func ParseNotifyUpdateResponse(rsp *http.Response) (*NotifyUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotifyUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *map[string]interface{} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2AuthorizeResponse parses an HTTP response from a Oauth2AuthorizeWithResponse call
func ParseOauth2AuthorizeResponse(rsp *http.Response) (*Oauth2AuthorizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDropshipmentv2CreateorderResponse parses an HTTP response from a Dropshipmentv2CreateorderWithResponse call
func ParseDropshipmentv2CreateorderResponse(rsp *http.Response) (*Dropshipmentv2CreateorderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dropshipmentv2CreateorderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// References of the orders with invalid address. *(Only if at least one order has an invalid address)*
				InvalidAddressCustomerRefIds *[]string `json:"invalid_address_customer_ref_ids,omitempty"`

				// List of created orders. *(Only if orders were successfully created)*
				Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDropshipmentv2CreateuserorderResponse parses an HTTP response from a Dropshipmentv2CreateuserorderWithResponse call
func ParseDropshipmentv2CreateuserorderResponse(rsp *http.Response) (*Dropshipmentv2CreateuserorderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dropshipmentv2CreateuserorderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// References of the orders with invalid address. *(Only if at least one order has an invalid address)*
				InvalidAddressCustomerRefIds *[]string `json:"invalid_address_customer_ref_ids,omitempty"`

				// List of created orders. *(Only if orders were successfully created)*
				Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
				User   *struct {
					// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
					Code *string `json:"code,omitempty"`

					// Unique identifier used by partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/).
					ExternalId *string `json:"external_id,omitempty"`
				} `json:"user,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDropshipmentv2DeleteResponse parses an HTTP response from a Dropshipmentv2DeleteWithResponse call
func ParseDropshipmentv2DeleteResponse(rsp *http.Response) (*Dropshipmentv2DeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dropshipmentv2DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *map[string]interface{} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDropshipmentv2GetorderstatusResponse parses an HTTP response from a Dropshipmentv2GetorderstatusWithResponse call
func ParseDropshipmentv2GetorderstatusResponse(rsp *http.Response) (*Dropshipmentv2GetorderstatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dropshipmentv2GetorderstatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Orders *[]DropshipmentGetOrderStatusObject `json:"orders,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDropshipmentv2UpdateResponse parses an HTTP response from a Dropshipmentv2UpdateWithResponse call
func ParseDropshipmentv2UpdateResponse(rsp *http.Response) (*Dropshipmentv2UpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Dropshipmentv2UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Orders *[]DropshipmentCreateOrderObject `json:"orders,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHeartv2GetResponse parses an HTTP response from a Heartv2GetWithResponse call
func ParseHeartv2GetResponse(rsp *http.Response) (*Heartv2GetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Heartv2GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// Signal Sampling Frequency (Hz).
				SamplingFrequency *int `json:"sampling_frequency,omitempty"`

				// Signal value in micro-volt (μV).
				Signal *[]int `json:"signal,omitempty"`

				// Where the user is wearing the device.
				//
				//
				// | Value | Description|
				// |---|---|
				// |0 | Right Wrist|
				// |1 | Left Wrist|
				// |2 | Right Arm|
				// |3 | Left Arm|
				// |4 | Right Foot|
				// |5 | Left Foot|
				// |6 | Between Legs|
				// |8 | Left part of the body|
				// |9 | Right part of the body|
				// |10 | Left leg|
				// |11 | Right leg|
				// |12 | Torso|
				Wearposition *int `json:"wearposition,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHeartv2ListResponse parses an HTTP response from a Heartv2ListWithResponse call
func ParseHeartv2ListResponse(rsp *http.Response) (*Heartv2ListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Heartv2ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// To know if there is more data to fetch or not.
				More *bool `json:"more,omitempty"`

				// Offset to use to retrieve the next data.
				Offset *int                      `json:"offset,omitempty"`
				Series *[]HeartMeasurementObject `json:"series,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeasurev2GetintradayactivityResponse parses an HTTP response from a Measurev2GetintradayactivityWithResponse call
func ParseMeasurev2GetintradayactivityResponse(rsp *http.Response) (*Measurev2GetintradayactivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Measurev2GetintradayactivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Series *struct {
					// $timestamp represents the epoch value of the intraday data
					Timestamp *struct {
						// Estimation of active calories burned (in Kcal). *(Use 'data_fields' to request this data.)*
						Calories *float32 `json:"calories,omitempty"`

						// ID of device that tracked the data. To retrieve information about this device, refer to : <a href='/api-reference/#operation/userv2-getdevice'>User v2 - Getdevice</a>.
						Deviceid *string `json:"deviceid,omitempty"`

						// Distance travelled (in meters). *(Use 'data_fields' to request this data.)*
						Distance *float32 `json:"distance,omitempty"`

						// Duration of the activity (in seconds). *(Use 'data_fields' to request this data.)*
						Duration *int `json:"duration,omitempty"`

						// Number of floors climbed. *(Use 'data_fields' to request this data.)*
						Elevation *float32 `json:"elevation,omitempty"`

						// Measured heart rate. *(Use 'data_fields' to request this data.)*
						HeartRate *int `json:"heart_rate,omitempty"`

						// Device model. Value can be:
						//
						//
						// | Value | Description|
						// |---|---|
						// |Withings WBS01 | Scale|
						// |WS30 | Scale|
						// |Kid Scale | Scale|
						// |Smart Body Analyzer | Scale|
						// |Body+ | Scale|
						// |Body Cardio | Scale|
						// |Body | Scale|
						// |WBS08 | Scale|
						// |Body Pro | Scale|
						// |WBS10 | Scale|
						// |WBS11 | Scale|
						// |Smart Baby Monitor | Babyphone|
						// |Withings Home | Babyphone|
						// |Withings Blood Pressure Monitor V1 | Blood Pressure Monitor|
						// |Withings Blood Pressure Monitor V2 | Blood Pressure Monitor|
						// |Withings Blood Pressure Monitor V3 | Blood Pressure Monitor|
						// |BPM Core | Blood Pressure Monitor|
						// |BPM Connect | Blood Pressure Monitor|
						// |BPM Connect Pro | Blood Pressure Monitor|
						// |Pulse | Activity Tracker|
						// |Activite | Activity Tracker|
						// |Activite (Pop, Steel) | Activity Tracker|
						// |Withings Go | Activity Tracker|
						// |Activite Steel HR | Activity Tracker|
						// |Activite Steel HR Sport Edition | Activity Tracker|
						// |Pulse HR | Activity Tracker|
						// |Move | Activity Tracker|
						// |Move ECG | Activity Tracker|
						// |ScanWatch | Activity Tracker|
						// |Aura Dock | Sleep Monitor|
						// |Aura Sensor | Sleep Monitor|
						// |Aura Sensor V2 | Sleep Monitor|
						// |Thermo | Smart Connected Thermometer|
						// |WUP01 | Gateway|
						Model *string `json:"model,omitempty"`

						//
						//
						// | Value | Description|
						// |---|---|
						// |1 | Withings WBS01|
						// |2 | WS30|
						// |3 | Kid Scale|
						// |4 | Smart Body Analyzer|
						// |5 | Body+|
						// |6 | Body Cardio|
						// |7 | Body|
						// |10 | WBS08|
						// |9 | Body Pro|
						// |11 | WBS10|
						// |12 | WBS11|
						// |21 | Smart Baby Monitor|
						// |22 | Withings Home|
						// |41 | Withings Blood Pressure Monitor V1|
						// |42 | Withings Blood Pressure Monitor V2|
						// |43 | Withings Blood Pressure Monitor V3|
						// |44 | BPM Core|
						// |45 | BPM Connect|
						// |46 | BPM Connect Pro|
						// |51 | Pulse|
						// |52 | Activite|
						// |53 | Activite (Pop, Steel)|
						// |54 | Withings Go|
						// |55 | Activite Steel HR|
						// |59 | Activite Steel HR Sport Edition|
						// |58 | Pulse HR|
						// |90 | Move|
						// |91 | Move ECG|
						// |92 | Move ECG|
						// |93 | ScanWatch|
						// |60 | Aura Dock|
						// |61 | Aura Sensor|
						// |63 | Aura Sensor V2|
						// |70 | Thermo|
						// |100 | WUP01|
						ModelId *int `json:"model_id,omitempty"`

						// Number of pool_lap performed. *(Use 'data_fields' to request this data.)*
						PoolLap *int `json:"pool_lap,omitempty"`

						// SpO2 measurement automatically tracked by a device tracker
						Spo2Auto *float32 `json:"spo2_auto,omitempty"`

						// Number of steps. *(Use 'data_fields' to request this data.)*
						Steps *int `json:"steps,omitempty"`

						// Number of strokes performed. *(Use 'data_fields' to request this data.)*
						Stroke *int `json:"stroke,omitempty"`
					} `json:"$timestamp,omitempty"`
				} `json:"series,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeasurev2GetactivityResponse parses an HTTP response from a Measurev2GetactivityWithResponse call
func ParseMeasurev2GetactivityResponse(rsp *http.Response) (*Measurev2GetactivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Measurev2GetactivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Activities *[]ActivityObject `json:"activities,omitempty"`

				// To know if there is more data to fetch or not.
				More *bool `json:"more,omitempty"`

				// Offset to use to retrieve the next data.
				Offset *int `json:"offset,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeasurev2GetworkoutsResponse parses an HTTP response from a Measurev2GetworkoutsWithResponse call
func ParseMeasurev2GetworkoutsResponse(rsp *http.Response) (*Measurev2GetworkoutsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Measurev2GetworkoutsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// To know if there is more data to fetch or not.
				More *bool `json:"more,omitempty"`

				// Offset to use to retrieve the next data.
				Offset *int             `json:"offset,omitempty"`
				Series *[]WorkoutObject `json:"series,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2GetdemoaccessResponse parses an HTTP response from a Oauth2GetdemoaccessWithResponse call
func ParseOauth2GetdemoaccessResponse(rsp *http.Response) (*Oauth2GetdemoaccessResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2GetdemoaccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// Your new Access Token.
				AccessToken *string `json:"access_token,omitempty"`

				// Access token expiry delay in seconds.
				ExpiresIn *int `json:"expires_in,omitempty"`

				// Your Refresh Token.
				RefreshToken *string `json:"refresh_token,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2RecoverauthorizationcodeResponse parses an HTTP response from a Oauth2RecoverauthorizationcodeWithResponse call
func ParseOauth2RecoverauthorizationcodeResponse(rsp *http.Response) (*Oauth2RecoverauthorizationcodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2RecoverauthorizationcodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				User *struct {
					// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
					Code *string `json:"code,omitempty"`
				} `json:"user,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2RefreshaccesstokenResponse parses an HTTP response from a Oauth2RefreshaccesstokenWithResponse call
func ParseOauth2RefreshaccesstokenResponse(rsp *http.Response) (*Oauth2RefreshaccesstokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2RefreshaccesstokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// Your new Access Token.
				AccessToken *string `json:"access_token,omitempty"`
				CsrfToken   *string `json:"csrf_token,omitempty"`

				// Access token expiry delay in seconds.
				ExpiresIn *int `json:"expires_in,omitempty"`

				// Your Refresh Token.
				RefreshToken *string `json:"refresh_token,omitempty"`

				// You can get only the scope that the user accepted with the Token you have. Scopes can be 'user.info' 'user.metrics' 'user.activity' 'user.sleepevents'  and must be separated by a coma.
				Scope *string `json:"scope,omitempty"`

				// HTTP Authorization Header format: Bearer
				TokenType *string `json:"token_type,omitempty"`

				// The id of the user.
				Userid *string `json:"userid,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2GetaccesstokenResponse parses an HTTP response from a Oauth2GetaccesstokenWithResponse call
func ParseOauth2GetaccesstokenResponse(rsp *http.Response) (*Oauth2GetaccesstokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2GetaccesstokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// Your new Access Token.
				AccessToken *string `json:"access_token,omitempty"`
				CsrfToken   *string `json:"csrf_token,omitempty"`

				// Access token expiry delay in seconds.
				ExpiresIn *int `json:"expires_in,omitempty"`

				// Your Refresh Token.
				RefreshToken *string `json:"refresh_token,omitempty"`

				// You can get only the scope that the user accepted with the Token you have. Scopes can be 'user.info' 'user.metrics' 'user.activity' 'user.sleepevents'  and must be separated by a coma.
				Scope *string `json:"scope,omitempty"`

				// HTTP Authorization Header format: Bearer
				TokenType *string `json:"token_type,omitempty"`

				// The id of the user.
				Userid *string `json:"userid,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrderv2GetdetailResponse parses an HTTP response from a Orderv2GetdetailWithResponse call
func ParseOrderv2GetdetailResponse(rsp *http.Response) (*Orderv2GetdetailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Orderv2GetdetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Orders *[]DropshipmentGetOrderStatusObject `json:"orders,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSignaturev2GetnonceResponse parses an HTTP response from a Signaturev2GetnonceWithResponse call
func ParseSignaturev2GetnonceResponse(rsp *http.Response) (*Signaturev2GetnonceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Signaturev2GetnonceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// A random timestamp based token to be used once in requiring signature API services to avoid replay attack
				Nonce *string `json:"nonce,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSleepv2GetResponse parses an HTTP response from a Sleepv2GetWithResponse call
func ParseSleepv2GetResponse(rsp *http.Response) (*Sleepv2GetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sleepv2GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Series *struct {
					// The end datetime for the sleep data. A single call can span up to 7 days maximum. To cover a wider time range, you will need to perform multiple calls.
					Enddate *int64 `json:"enddate,omitempty"`

					// Heart Rate. *(Use 'data_fields' to request this data.)*
					Hr *struct {
						// $timestamp represents the epoch value of the heart rate data, value of this key will be the heart rate data
						Timestamp *int `json:"$timestamp,omitempty"`
					} `json:"hr,omitempty"`

					// Device model. Value can be:
					//
					//
					// | Value | Description|
					// |---|---|
					// |Aura Dock | Sleep Monitor|
					// |Aura Sensor | Sleep Monitor|
					// |Aura Sensor V2 | Sleep Monitor|
					// |Pulse | Activity Tracker|
					// |Activite | Activity Tracker|
					// |Activite (Pop, Steel) | Activity Tracker|
					// |Withings Go | Activity Tracker|
					// |Activite Steel HR | Activity Tracker|
					// |Activite Steel HR Sport Edition | Activity Tracker|
					// |Pulse HR | Activity Tracker|
					// |Move | Activity Tracker|
					// |Move ECG | Activity Tracker|
					// |ScanWatch | Activity Tracker|
					Model *string `json:"model,omitempty"`

					//
					//
					// | Value | Description|
					// |---|---|
					// |60 | Aura Dock|
					// |61 | Aura Sensor|
					// |63 | Aura Sensor V2|
					// |51 | Pulse|
					// |52 | Activite|
					// |53 | Activite (Pop, Steel)|
					// |54 | Withings Go|
					// |55 | Activite Steel HR|
					// |59 | Activite Steel HR Sport Edition|
					// |58 | Pulse HR|
					// |90 | Move|
					// |91 | Move ECG|
					// |92 | Move ECG|
					// |93 | ScanWatch|
					ModelId *int `json:"model_id,omitempty"`

					// Heart rate variability - Root mean square of the successive differences over "a few seconds"
					Rmssd *struct {
						Timestamp *int `json:"$timestamp,omitempty"`
					} `json:"rmssd,omitempty"`

					// Respiration Rate. *(Use 'data_fields' to request this data.)*
					Rr *struct {
						// $timestamp represents the epoch value of the respiration rate data, value of this key will be the respiration rate data
						Timestamp *int `json:"$timestamp,omitempty"`
					} `json:"rr,omitempty"`

					// Heart rate variability - Standard deviation of the NN over 1 minute
					Sdnn1 *struct {
						Timestamp *int `json:"$timestamp,omitempty"`
					} `json:"sdnn_1,omitempty"`

					// Total snoring time
					Snoring *struct {
						Timestamp *int `json:"$timestamp,omitempty"`
					} `json:"snoring,omitempty"`

					// The starting datetime for the sleep state data.
					Startdate *int64 `json:"startdate,omitempty"`

					// The state of sleeping. Values can be:
					//
					//
					// | Value | Description|
					// |---|---|
					// |0 | Sleep state awake|
					// |1 | Sleep state light|
					// |2 | Sleep state deep|
					// |3 | Sleep state rem|
					// |4 | Sleep manual|
					// |5 | Sleep unspecified|
					State *int `json:"state,omitempty"`
				} `json:"series,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSleepv2GetsummaryResponse parses an HTTP response from a Sleepv2GetsummaryWithResponse call
func ParseSleepv2GetsummaryResponse(rsp *http.Response) (*Sleepv2GetsummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Sleepv2GetsummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				// To know if there is more data to fetch or not.
				More *bool `json:"more,omitempty"`

				// Offset to use to retrieve the next data.
				Offset *int `json:"offset,omitempty"`
				Series *[]struct {
					Created *int64 `json:"created,omitempty"`

					// Details of sleep.
					Data *struct {
						// Medical grade AHI. Only available for devices purchased in Europe and Australia, with the sleep apnea detection feature activated. Average number of hypopnea and apnea episodes per hour, that occured during sleep time.
						ApneaHypopneaIndex *int `json:"apnea_hypopnea_index,omitempty"`

						// Duration of sleep when night comes from external source (light, deep and rem sleep durations are null in this case). *(Use 'data_fields' to request this data.)*
						Asleepduration *int `json:"asleepduration,omitempty"`

						// Wellness metric, available for all Sleep and Sleep Analyzer devices. Intensity of <a href='/api-reference/#section/Glossary'>breathing disturbances</a>
						BreathingDisturbancesIntensity *int `json:"breathing_disturbances_intensity,omitempty"`

						// Duration in state deep sleep (in seconds). *(Use 'data_fields' to request this data.)*
						Deepsleepduration *int `json:"deepsleepduration,omitempty"`

						// Time to sleep (in seconds). (deprecated) *(Use 'data_fields' to request this data.)*
						Durationtosleep *int `json:"durationtosleep,omitempty"`

						// Time to wake up (in seconds). (deprecated) *(Use 'data_fields' to request this data.)*
						Durationtowakeup *int `json:"durationtowakeup,omitempty"`

						// Average heart rate. *(Use 'data_fields' to request this data.)*
						HrAverage *int `json:"hr_average,omitempty"`

						// Maximal heart rate. *(Use 'data_fields' to request this data.)*
						HrMax *int `json:"hr_max,omitempty"`

						// Minimal heart rate. *(Use 'data_fields' to request this data.)*
						HrMin *int `json:"hr_min,omitempty"`

						// Duration in state light sleep (in seconds). *(Use 'data_fields' to request this data.)*
						Lightsleepduration *int `json:"lightsleepduration,omitempty"`

						// Count of the REM sleep phases. *(Use 'data_fields' to request this data.)*
						NbRemEpisodes *int `json:"nb_rem_episodes,omitempty"`

						// Events list happened during the night
						NightEvents json.RawMessage `json:"night_events,omitempty"`

						// Number of times the user got out of bed during the night. *(Use 'data_fields' to request this data.)*
						OutOfBedCount *int `json:"out_of_bed_count,omitempty"`

						// Duration in state REM sleep (in seconds). *(Use 'data_fields' to request this data.)*
						Remsleepduration *int `json:"remsleepduration,omitempty"`

						// Average respiration rate. *(Use 'data_fields' to request this data.)*
						RrAverage *int `json:"rr_average,omitempty"`

						// Maximal respiration rate. *(Use 'data_fields' to request this data.)*
						RrMax *int `json:"rr_max,omitempty"`

						// Minimal respiration rate. *(Use 'data_fields' to request this data.)*
						RrMin *int `json:"rr_min,omitempty"`

						// Ratio of the total sleep time over the time spent in bed. *(Use 'data_fields' to request this data.)*
						SleepEfficiency *float32 `json:"sleep_efficiency,omitempty"`

						// Time spent in bed before falling asleep. *(Use 'data_fields' to request this data.)*
						SleepLatency *int `json:"sleep_latency,omitempty"`

						// Sleep score
						SleepScore *int `json:"sleep_score,omitempty"`

						// Total snoring time
						Snoring *int `json:"snoring,omitempty"`

						// Numbers of snoring episodes of at least one minute
						Snoringepisodecount *int `json:"snoringepisodecount,omitempty"`

						// Total time spent asleep. Sum of light, deep and rem durations. *(Use 'data_fields' to request this data.)*
						TotalSleepTime *int `json:"total_sleep_time,omitempty"`

						// Total time spent in bed. *(Use 'data_fields' to request this data.)*
						TotalTimeinbed *int `json:"total_timeinbed,omitempty"`

						// Time spent in bed after waking up. *(Use 'data_fields' to request this data.)*
						WakeupLatency *int `json:"wakeup_latency,omitempty"`

						// Number of times the user woke up while in bed. Does not include the number of times the user got out of bed. *(Use 'data_fields' to request this data.)*
						Wakeupcount *int `json:"wakeupcount,omitempty"`

						// Time spent awake (in seconds). *(Use 'data_fields' to request this data.)*
						Wakeupduration *int `json:"wakeupduration,omitempty"`

						// Time spent awake in bed after falling asleep for the 1st time during the night. *(Use 'data_fields' to request this data.)*
						Waso *int `json:"waso,omitempty"`
					} `json:"data,omitempty"`

					// Date at which the measure was taken or entered.
					Date *string `json:"date,omitempty"`

					// The end datetime for the sleep data. A single call can span up to 7 days maximum. To cover a wider time range, you will need to perform multiple calls.
					Enddate *int64 `json:"enddate,omitempty"`

					// The source for sleep data. Value can be 16 for a tracker or 32 for a Sleep Monitor.
					Model *int `json:"model,omitempty"`

					//
					//
					// | Value | Description|
					// |---|---|
					// |60 | Aura Dock|
					// |61 | Aura Sensor|
					// |63 | Aura Sensor V2|
					// |51 | Pulse|
					// |52 | Activite|
					// |53 | Activite (Pop, Steel)|
					// |54 | Withings Go|
					// |55 | Activite Steel HR|
					// |59 | Activite Steel HR Sport Edition|
					// |58 | Pulse HR|
					// |90 | Move|
					// |91 | Move ECG|
					// |92 | Move ECG|
					// |93 | ScanWatch|
					ModelId *int `json:"model_id,omitempty"`

					// The timestamp of the last modification.
					Modified *int64 `json:"modified,omitempty"`

					// The starting datetime for the sleep state data.
					Startdate *int64 `json:"startdate,omitempty"`

					// Timezone for the date.
					Timezone *string `json:"timezone,omitempty"`
				} `json:"series,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2ActivateResponse parses an HTTP response from a Userv2ActivateWithResponse call
func ParseUserv2ActivateResponse(rsp *http.Response) (*Userv2ActivateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2ActivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Devices *[]UserDeviceMacObject `json:"devices,omitempty"`
				User    *struct {
					// Authorization Code that must be used to retrieve access_token and refresh_token. (Read the "Get access to your user's data" section of your [integration guide](/developer-guide/v3/withings-solutions/integration-guides) to learn more about how to get this parameter.)
					Code *string `json:"code,omitempty"`

					// Unique identifier used by partner to identify the end-user. Will be attached to the [data update notifications](/developer-guide/v3/data-api/keep-user-data-up-to-date/).
					ExternalId *string `json:"external_id,omitempty"`
				} `json:"user,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2GetResponse parses an HTTP response from a Userv2GetWithResponse call
func ParseUserv2GetResponse(rsp *http.Response) (*Userv2GetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				User *struct {
					// Unix timestamp of user's birthdate
					Birthdate *int `json:"birthdate,omitempty"`

					// User's email address
					Email *string `json:"email,omitempty"`

					// User's firstname
					Firstname *string `json:"firstname,omitempty"`

					// User's gender (0: man, 1: woman)
					Gender *int `json:"gender,omitempty"`

					// User's lastname
					Lastname *string `json:"lastname,omitempty"`

					// User consent to receiving sales and marketing communication from Withings (0: user does not consent, 1: user does consent)
					Mailingpref *bool `json:"mailingpref,omitempty"`

					// User's phone number. *(Only if set)*
					Phonenumber *string `json:"phonenumber,omitempty"`

					// User's language preference. Examples: en_EN / en_US / de_DE / es_ES / fr_FR / it_IT / ja_JA / ko_KR / nl_NL / pt_PT / ru_RU / zh_CN
					Preflang *string `json:"preflang,omitempty"`

					// User's shortname
					Shortname *string `json:"shortname,omitempty"`

					// User's timezone. Examples: "Europe/Paris" / "America/New_York". A complete list of all possible timezones can be found on the "TZ database name" column of this page : https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
					Timezone *string `json:"timezone,omitempty"`

					// User's unit preferences (cf. [Unit preferences](#section/Models/Unit-preferences) model).
					UnitPref *struct {
						Distance    *int `json:"distance,omitempty"`
						Height      *int `json:"height,omitempty"`
						Temperature *int `json:"temperature,omitempty"`
						Weight      *int `json:"weight,omitempty"`
					} `json:"unit_pref,omitempty"`
				} `json:"user,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2GetdeviceResponse parses an HTTP response from a Userv2GetdeviceWithResponse call
func ParseUserv2GetdeviceResponse(rsp *http.Response) (*Userv2GetdeviceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2GetdeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Devices *[]UserDeviceObject `json:"devices,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2GetgoalsResponse parses an HTTP response from a Userv2GetgoalsWithResponse call
func ParseUserv2GetgoalsResponse(rsp *http.Response) (*Userv2GetgoalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2GetgoalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Goals *struct {
					// Sleep duration (in seconds).
					Sleep *int `json:"sleep,omitempty"`

					// Number of steps per day.
					Steps *int `json:"steps,omitempty"`

					// Weight.
					Weight *struct {
						// Power of ten to multiply the ```value``` field to get the real value.<br>Formula: ```value * 10^unit = real value```.<br>Eg: ```value = 20 and unit = -1 => real value = 2```.
						Unit *int `json:"unit,omitempty"`

						// Value for the measure in S.I. units (kilograms, meters etc...). Value should be multiplied by 10 to the power of ```units``` to get the real value.
						Value *int `json:"value,omitempty"`
					} `json:"weight,omitempty"`
				} `json:"goals,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2LinkResponse parses an HTTP response from a Userv2LinkWithResponse call
func ParseUserv2LinkResponse(rsp *http.Response) (*Userv2LinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2LinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *struct {
				Devices *[]UserDeviceMacObject `json:"devices,omitempty"`
			} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserv2UnlinkResponse parses an HTTP response from a Userv2UnlinkWithResponse call
func ParseUserv2UnlinkResponse(rsp *http.Response) (*Userv2UnlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Userv2UnlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Response data.
			Body *map[string]interface{} `json:"body,omitempty"`

			// Response status. See <a href='#section/Response-status'>Status</a> section for details.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
