// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: session.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createSession = `-- name: CreateSession :one
INSERT INTO session (data)
VALUES ($1)
returning session_id
`

func (q *Queries) CreateSession(ctx context.Context, data pgtype.JSONB) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createSession, data)
	var session_id uuid.UUID
	err := row.Scan(&session_id)
	return session_id, err
}

const getSession = `-- name: GetSession :one
select session_id, data from session
where session_id = $1
`

type GetSessionRow struct {
	SessionID uuid.UUID
	Data      pgtype.JSONB
}

func (q *Queries) GetSession(ctx context.Context, sessionID uuid.UUID) (GetSessionRow, error) {
	row := q.db.QueryRow(ctx, getSession, sessionID)
	var i GetSessionRow
	err := row.Scan(&i.SessionID, &i.Data)
	return i, err
}

const upsertSession = `-- name: UpsertSession :exec
INSERT INTO session (session_id, data)
VALUES ($1, $2)
ON CONFLICT (session_id) DO UPDATE
    SET data = excluded.data
`

type UpsertSessionParams struct {
	SessionID uuid.UUID
	Data      pgtype.JSONB
}

func (q *Queries) UpsertSession(ctx context.Context, arg UpsertSessionParams) error {
	_, err := q.db.Exec(ctx, upsertSession, arg.SessionID, arg.Data)
	return err
}
