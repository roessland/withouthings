// Code generated by mockery v2.24.0. DO NOT EDIT.

package withings

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockRepo is an autogenerated mock type for the Repo type
type MockRepo struct {
	mock.Mock
}

type MockRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepo) EXPECT() *MockRepo_Expecter {
	return &MockRepo_Expecter{mock: &_m.Mock}
}

// AuthCodeURL provides a mock function with given fields: nonce
func (_m *MockRepo) AuthCodeURL(nonce string) string {
	ret := _m.Called(nonce)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(nonce)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockRepo_AuthCodeURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthCodeURL'
type MockRepo_AuthCodeURL_Call struct {
	*mock.Call
}

// AuthCodeURL is a helper method to define mock.On call
//   - nonce string
func (_e *MockRepo_Expecter) AuthCodeURL(nonce interface{}) *MockRepo_AuthCodeURL_Call {
	return &MockRepo_AuthCodeURL_Call{Call: _e.mock.On("AuthCodeURL", nonce)}
}

func (_c *MockRepo_AuthCodeURL_Call) Run(run func(nonce string)) *MockRepo_AuthCodeURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockRepo_AuthCodeURL_Call) Return(_a0 string) *MockRepo_AuthCodeURL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepo_AuthCodeURL_Call) RunAndReturn(run func(string) string) *MockRepo_AuthCodeURL_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessToken provides a mock function with given fields: ctx, authCode
func (_m *MockRepo) GetAccessToken(ctx context.Context, authCode string) (*Token, error) {
	ret := _m.Called(ctx, authCode)

	var r0 *Token
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Token, error)); ok {
		return rf(ctx, authCode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Token); ok {
		r0 = rf(ctx, authCode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, authCode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_GetAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessToken'
type MockRepo_GetAccessToken_Call struct {
	*mock.Call
}

// GetAccessToken is a helper method to define mock.On call
//   - ctx context.Context
//   - authCode string
func (_e *MockRepo_Expecter) GetAccessToken(ctx interface{}, authCode interface{}) *MockRepo_GetAccessToken_Call {
	return &MockRepo_GetAccessToken_Call{Call: _e.mock.On("GetAccessToken", ctx, authCode)}
}

func (_c *MockRepo_GetAccessToken_Call) Run(run func(ctx context.Context, authCode string)) *MockRepo_GetAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepo_GetAccessToken_Call) Return(_a0 *Token, _a1 error) *MockRepo_GetAccessToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_GetAccessToken_Call) RunAndReturn(run func(context.Context, string) (*Token, error)) *MockRepo_GetAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// NotifyList provides a mock function with given fields: ctx, accessToken, params
func (_m *MockRepo) NotifyList(ctx context.Context, accessToken string, params NotifyListParams) (*NotifyListResponse, error) {
	ret := _m.Called(ctx, accessToken, params)

	var r0 *NotifyListResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, NotifyListParams) (*NotifyListResponse, error)); ok {
		return rf(ctx, accessToken, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, NotifyListParams) *NotifyListResponse); ok {
		r0 = rf(ctx, accessToken, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*NotifyListResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, NotifyListParams) error); ok {
		r1 = rf(ctx, accessToken, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_NotifyList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifyList'
type MockRepo_NotifyList_Call struct {
	*mock.Call
}

// NotifyList is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - params NotifyListParams
func (_e *MockRepo_Expecter) NotifyList(ctx interface{}, accessToken interface{}, params interface{}) *MockRepo_NotifyList_Call {
	return &MockRepo_NotifyList_Call{Call: _e.mock.On("NotifyList", ctx, accessToken, params)}
}

func (_c *MockRepo_NotifyList_Call) Run(run func(ctx context.Context, accessToken string, params NotifyListParams)) *MockRepo_NotifyList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(NotifyListParams))
	})
	return _c
}

func (_c *MockRepo_NotifyList_Call) Return(_a0 *NotifyListResponse, _a1 error) *MockRepo_NotifyList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_NotifyList_Call) RunAndReturn(run func(context.Context, string, NotifyListParams) (*NotifyListResponse, error)) *MockRepo_NotifyList_Call {
	_c.Call.Return(run)
	return _c
}

// NotifySubscribe provides a mock function with given fields: ctx, accessToken, params
func (_m *MockRepo) NotifySubscribe(ctx context.Context, accessToken string, params NotifySubscribeParams) (*NotifySubscribeResponse, error) {
	ret := _m.Called(ctx, accessToken, params)

	var r0 *NotifySubscribeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, NotifySubscribeParams) (*NotifySubscribeResponse, error)); ok {
		return rf(ctx, accessToken, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, NotifySubscribeParams) *NotifySubscribeResponse); ok {
		r0 = rf(ctx, accessToken, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*NotifySubscribeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, NotifySubscribeParams) error); ok {
		r1 = rf(ctx, accessToken, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_NotifySubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotifySubscribe'
type MockRepo_NotifySubscribe_Call struct {
	*mock.Call
}

// NotifySubscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - params NotifySubscribeParams
func (_e *MockRepo_Expecter) NotifySubscribe(ctx interface{}, accessToken interface{}, params interface{}) *MockRepo_NotifySubscribe_Call {
	return &MockRepo_NotifySubscribe_Call{Call: _e.mock.On("NotifySubscribe", ctx, accessToken, params)}
}

func (_c *MockRepo_NotifySubscribe_Call) Run(run func(ctx context.Context, accessToken string, params NotifySubscribeParams)) *MockRepo_NotifySubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(NotifySubscribeParams))
	})
	return _c
}

func (_c *MockRepo_NotifySubscribe_Call) Return(_a0 *NotifySubscribeResponse, _a1 error) *MockRepo_NotifySubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_NotifySubscribe_Call) RunAndReturn(run func(context.Context, string, NotifySubscribeParams) (*NotifySubscribeResponse, error)) *MockRepo_NotifySubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// RefreshAccessToken provides a mock function with given fields: ctx, refreshToken
func (_m *MockRepo) RefreshAccessToken(ctx context.Context, refreshToken string) (*Token, error) {
	ret := _m.Called(ctx, refreshToken)

	var r0 *Token
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Token, error)); ok {
		return rf(ctx, refreshToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Token); ok {
		r0 = rf(ctx, refreshToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, refreshToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_RefreshAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefreshAccessToken'
type MockRepo_RefreshAccessToken_Call struct {
	*mock.Call
}

// RefreshAccessToken is a helper method to define mock.On call
//   - ctx context.Context
//   - refreshToken string
func (_e *MockRepo_Expecter) RefreshAccessToken(ctx interface{}, refreshToken interface{}) *MockRepo_RefreshAccessToken_Call {
	return &MockRepo_RefreshAccessToken_Call{Call: _e.mock.On("RefreshAccessToken", ctx, refreshToken)}
}

func (_c *MockRepo_RefreshAccessToken_Call) Run(run func(ctx context.Context, refreshToken string)) *MockRepo_RefreshAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepo_RefreshAccessToken_Call) Return(_a0 *Token, _a1 error) *MockRepo_RefreshAccessToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_RefreshAccessToken_Call) RunAndReturn(run func(context.Context, string) (*Token, error)) *MockRepo_RefreshAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// SleepGet provides a mock function with given fields: ctx, accessToken, params
func (_m *MockRepo) SleepGet(ctx context.Context, accessToken string, params SleepGetParams) (*SleepGetResponse, error) {
	ret := _m.Called(ctx, accessToken, params)

	var r0 *SleepGetResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, SleepGetParams) (*SleepGetResponse, error)); ok {
		return rf(ctx, accessToken, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, SleepGetParams) *SleepGetResponse); ok {
		r0 = rf(ctx, accessToken, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SleepGetResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, SleepGetParams) error); ok {
		r1 = rf(ctx, accessToken, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_SleepGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SleepGet'
type MockRepo_SleepGet_Call struct {
	*mock.Call
}

// SleepGet is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - params SleepGetParams
func (_e *MockRepo_Expecter) SleepGet(ctx interface{}, accessToken interface{}, params interface{}) *MockRepo_SleepGet_Call {
	return &MockRepo_SleepGet_Call{Call: _e.mock.On("SleepGet", ctx, accessToken, params)}
}

func (_c *MockRepo_SleepGet_Call) Run(run func(ctx context.Context, accessToken string, params SleepGetParams)) *MockRepo_SleepGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(SleepGetParams))
	})
	return _c
}

func (_c *MockRepo_SleepGet_Call) Return(_a0 *SleepGetResponse, _a1 error) *MockRepo_SleepGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_SleepGet_Call) RunAndReturn(run func(context.Context, string, SleepGetParams) (*SleepGetResponse, error)) *MockRepo_SleepGet_Call {
	_c.Call.Return(run)
	return _c
}

// SleepGetsummary provides a mock function with given fields: ctx, accessToken, params
func (_m *MockRepo) SleepGetsummary(ctx context.Context, accessToken string, params SleepGetSummaryParams) (*SleepGetsummaryResponse, error) {
	ret := _m.Called(ctx, accessToken, params)

	var r0 *SleepGetsummaryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, SleepGetSummaryParams) (*SleepGetsummaryResponse, error)); ok {
		return rf(ctx, accessToken, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, SleepGetSummaryParams) *SleepGetsummaryResponse); ok {
		r0 = rf(ctx, accessToken, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SleepGetsummaryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, SleepGetSummaryParams) error); ok {
		r1 = rf(ctx, accessToken, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepo_SleepGetsummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SleepGetsummary'
type MockRepo_SleepGetsummary_Call struct {
	*mock.Call
}

// SleepGetsummary is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - params SleepGetSummaryParams
func (_e *MockRepo_Expecter) SleepGetsummary(ctx interface{}, accessToken interface{}, params interface{}) *MockRepo_SleepGetsummary_Call {
	return &MockRepo_SleepGetsummary_Call{Call: _e.mock.On("SleepGetsummary", ctx, accessToken, params)}
}

func (_c *MockRepo_SleepGetsummary_Call) Run(run func(ctx context.Context, accessToken string, params SleepGetSummaryParams)) *MockRepo_SleepGetsummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(SleepGetSummaryParams))
	})
	return _c
}

func (_c *MockRepo_SleepGetsummary_Call) Return(_a0 *SleepGetsummaryResponse, _a1 error) *MockRepo_SleepGetsummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepo_SleepGetsummary_Call) RunAndReturn(run func(context.Context, string, SleepGetSummaryParams) (*SleepGetsummaryResponse, error)) *MockRepo_SleepGetsummary_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockRepo interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockRepo creates a new instance of MockRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockRepo(t mockConstructorTestingTNewMockRepo) *MockRepo {
	mock := &MockRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
